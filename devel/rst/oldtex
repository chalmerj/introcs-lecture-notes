% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Introductory Programming in C\#}
\date{January 19, 2012}
\release{1.0}
\author{Andrew N. Harrington and George K. Thiruvathukal}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Context}
\label{context:introductory-programming-in-c}\label{context::doc}\label{context:context}

\section{Introduction to the Notes}
\label{intro::doc}\label{intro:introduction-to-the-notes}
These notes are designed for Comp 170.  They are closely tied to the
excellent C\# introduction in Rob Miles' free online
\href{http://www.robmiles.com/c-yellow-book/Rob\%20Miles\%20CSharp\%20Yellow\%20Book\%202011.pdf}{C\# Yellow Book}.

These notes will follow mostly the same order, adding some extra explanations, examples,
and challenges, and introduce the Mono open source implementation of C\#.

The content here will be interspersed with comments about where to look at parts of Miles book,
with clarifications of the book and comments about what is not important for a
beginner in the book.

Computer programs are designed to run on a computer and solve problems.
Though the initial problems will be tiny and often silly, they will serve as learning tools
to prepare for substantive problems.


\section{Comments on Miles Chapter 1}
\label{milesintro:comments-on-miles-chapter-1}\label{milesintro::doc}
Miles Chapter 1 on Computers and Programs makes a good introduction and gives context.
\emph{Read} for the grounding it gives.

The chapter makes some reference to Microsoft,
the original creator of C\#, and its
Visual Studio software development environment, which works only on Windows machines,
and costs a lot if you are not a student.
The optional text by Lewis discussed Visual Studio at some length.
The next section of these notes will introduce an alternative to the
Microsoft environment: Mono, which is free,
open-source software that makes C\# available for multiple platforms:
Windows, Mac, or Linux machines.


\chapter{C\# Data and Operations}
\label{data::doc}\label{data:c-data-and-operations}

\section{Development Tools}
\label{monotools:development-tools}\label{monotools::doc}

\subsection{About Software Development Kits (SDKs)}
\label{monotools:about-software-development-kits-sdks}
A software development kit (SDK) is a set of tools for developing in a
particular programming language (in our class, C\#). Developing in a
language means everything from compiling to running and (when things
go wrong) to debugging programs.

The Microsoft SDK is the proprietary implementation of .Net. It runs
only on Windows and is the primary development framework for all
things Microsoft.

The Mono Project SDK \textless{}\href{http://mono-project.com}{http://mono-project.com}\textgreater{} is the free/open source
equivalent implementation of the Microsoft SDK. It runs on all major platforms (including Windows) and is needed in situations where you want to develop .Net applications on non-Windows platforms.

As an interesting aside, the company whose developers lead the work on
the Mono SDK are working on commercial tools that allow you to
develop/run applications written in .Net on Apple iOS and Android
mobile devices (phones and tablets).


\subsection{About Integrated Development Environments (IDE)}
\label{monotools:about-integrated-development-environments-ide}
While just about everything you need to create programs can, indeed,
be found in the SDK, it is not long before you wish there were an ``app
for that'' so to speak. While most programmers who developed code (like
your instructors) in the 1970s-1990s learned to program directly with
the SDK using the \emph{command line}, today's programmers largely to
prefer working in an IDE.

There are two major IDEs for .Net development, which we explain briefly below:
\begin{itemize}
\item {} 
Visual Studio is the Microsoft IDE that interfaces directly to the
Microsoft SDK.

\item {} 
MonoDevelop is the free/open source IDE for developing applications
using the Mono SDK on Windows and all other platforms (in
particular, Linux and OS X).

\end{itemize}

In addition, there is another Windows-specific IDE, SharpDevelop, that
inspired the creation of MonoDevelop. It is still actively maintained
and provides a somewhat ``lighter weight'' alternative to Visual Studio
for Windows users. Like MonoDevelop, it is aimed at developers who
would prefer a more free/open source ``friendly'' version.


\subsection{Our Approach}
\label{monotools:our-approach}
In the interest of providing a consistent experience for our students,
we will be using Mono (the SDK) and MonoDevelop (the IDE) for
everything we demonstrate in class. We will also be encouraging you to
use it for your work, especially if you are interested in
non-Microsoft platforms.

Our notes assume for the most part that you are working with Mono and
MonoDevelop. In most cases, what we are showing you in Mono and
MonoDevelop will translate almost \emph{as is} to the Microsoft
equivalents. However, there are some tools, such as the \code{csharp}
interpreter, that have a rough analog in Microsoft's tools but in a somewhat
limited form. As there is significant evolution of both the Microsoft
and Mono \emph{toolchains}--a fancy word we want you to know and a more
elegant way of saying SDK--we'll issue updates to these notes.


\subsection{Installing Mono}
\label{monotools:installing-mono}
Because the Mono Project web page is known to change frequently, these
instructions are designed to be as generic as possible. If you have
any questions, you should contact the intructors immediately or seek
tutoring help.


\subsection{OS X}
\label{monotools:os-x}\begin{enumerate}
\item {} 
Go to \textless{}\href{http://mono-project.com}{http://mono-project.com}\textgreater{}.

\item {} 
Look for the Mono downloads link. You want to get the latest \emph{stable}
version of Mono for OS X. For this class, you need version 2.10 or
later.

\item {} 
You may see a link to download \emph{Runtime} or \emph{SDK}. Make sure you select SDK.

\item {} 
For OS X, the SDK is distributed as a DMG disk image. You'll need
to download this image and double-click it. Open the image and run
the installer. Administrative privileges are required to run the
installer, so if you do not know this information, please stop
here.

\item {} 
Once installation is completed, you have everything needed to start
using the IDE, MonoDevelop.

\item {} 
Now go to \textless{}\href{http://mono-develop.com}{http://mono-develop.com}\textgreater{}.

\item {} 
As with Mono, we need to look for the downloads link.
You should download the \emph{stable} version.

\item {} 
As with Mono, you will see a DMG file,
which you should download and double-click to mount on your desktop.

\item {} 
This time, you will see an App for MonoDevelop,
which you can drag and drop into the Applications foldeer.

\end{enumerate}

Here is how to do a quick sanity check of your Mono setup:
\begin{enumerate}
\item {} 
Go to Applications -\textgreater{} Utilities and launch the Terminal
application. (Terminal is how you get to a command-line shell in OS X.)

\item {} 
You'll see a prompt that looks like this
\code{computername:folder user\$}.
This means that Terminal is ready for input.

\item {} 
Type \code{which csharp} and hit enter/return. You should see
\code{/usr/bin/csharp} as output. \code{csharp} is the C\# interpreter.

\item {} 
Type \code{which dmcs} and hit enter/return. You should see
\code{/usr/bin/dmcs} as output.  \code{dmcs} is one of the interfaces to
the C\# compiler.

\item {} 
If the two preceding steps were successful, you can launch
MonoDevelop by double-clicking the icon in your Applications
folder. (You won't know what to do with it yet, but at least you can
verify that it launches correctly and then use Command-Q to exit.)

\end{enumerate}


\subsection{Windows}
\label{monotools:windows}\begin{enumerate}
\item {} 
Go to \textless{}\href{http://mono-project.com}{http://mono-project.com}\textgreater{}.

\item {} 
Look for the Mono downloads link. You want to get the latest
\emph{stable} version of Mono for Windows. For this class, you need version
2.10 or later.

\item {} 
You may see a link to download \emph{Runtime} or \emph{SDK}. Make sure you select SDK.

\item {} 
For Windows, there is only one option to download the SDK. It is a
self-extracting executable, so you will need to double click it to
install. For Vista and 7 users, you may need to check your taskbar to
see whether the installer is being held up by Microsoft's enhanced
security, UAM, that makes sure you really want to install something
you downloaded from the internet.

\item {} 
Once installation is completed, you have everything needed to start
using the IDE, MonoDevelop.

\item {} 
Now go to \textless{}\href{http://mono-develop.com}{http://mono-develop.com}\textgreater{}.

\item {} 
As with Mono, we need to look for the downloads link. You should
download the \emph{stable} version.

\item {} 
As with Mono, you will see a self-extracting installer,
which you should run as before.

\end{enumerate}

Here is how to do a quick sanity check of your Mono setup:
\begin{enumerate}
\item {} 
Open the Start Menu and type ``mono'' in the text field at the bottom.
You should see a short list places ``mono'' appears.

\item {} 
Click on the choice that says ``Mono 2.10... Command prompt''.
If it comes up, you are all set.
Close the window, or save it for later use....
You can also find the program in the Start Menu manually,
finding the Mono folder, expanding it, and clicking on{]}
the Mono Command Prompt.

\item {} 
If the two preceding steps were successful, you can launch
MonoDevelop by double-clicking the icon in your Applications
folder. (You won't know what to do with it yet, but at least you can
verify that it launches correctly and then close the window.
Ctrl-Q is a shortcut.)

\end{enumerate}


\subsection{Linux}
\label{monotools:linux}
We only provide instructions for Debian-based Linux distributions such
as Ubuntu.
\begin{enumerate}
\item {} 
Using the command-line \code{apt-get} tool, you can install everything
that you need using \code{apt-get install monodevelop}. This should be
run as the \textbf{root} user (using the \code{sudo} command).

\item {} 
You can test the sanity of your setup by following the instructions
under OS X.

\end{enumerate}

MonoDevelop releases on Linux tend to lag behind the official stable
release.

This page,
\href{https://launchpad.net/~keks9n/+archive/monodevelop-latest}{https://launchpad.net/\textasciitilde{}keks9n/+archive/monodevelop-latest},

describes
how to update your MonoDevelop setup if it is not version 2.8 or later
as we'll need for this course.

We wish to stress that Linux is recommended for students who already
have a bit of programming experience under their belts. It can take a
significant amount of energy to get a Linux setup up and running and
to tweak it to your liking. While it has gotten ever so much easier
since the 1990s when it first appeared, we encourage you to set it up
perhaps a bit later in the semester or consider running it using
virtualization software (on Mac or Windows) such as VirtualBox or
VMware.


\section{Lab Exercise: Editing, Compiling, and Running}
\label{lab-edit-compile-run:lab-exercise-editing-compiling-and-running}\label{lab-edit-compile-run::doc}

\subsection{Summary}
\label{lab-edit-compile-run:summary}
This first lab is aimed at taking you through the end-to-end process of
writing and running a basic computer program. As with all things in
life, we will learn in this lab that becoming a programmer requires you
to learn a number of other things along the way.

In software development/engineering parlance, we typically describe a
scenario as a \emph{workflow}, which can be thought of as a series of steps
that are possibly repeated. The workflow of programming can loosely be
defined as follows:
\begin{enumerate}
\item {} 
Use a text editor to write your source code (human readable).

\item {} 
Compile your code using the Software Development Kit (SDK) into
object code.

\item {} 
Link your object code to create an executable. (There are other
kinds of results to produce, but we will start with the idea of an
executable program to keep things simple.)  The default is to nave
an executable program created with compilation, automatically.

\item {} 
Run your program. Even for the most seasoned developers, your
program may not work entirely right the first time, so you may end
up repeating these steps (debugging).

\end{enumerate}

As we will learn later in the course, development environments such as
Visual Studio (from Microsoft) and MonoDevelop (an open source
implementation similar to Visual Studio) basically shield you from the
details of understanding the workflow in detail. We think it is
important that you \emph{learn} this workflow from day one, because many types
of software development don't always have the easiest software
development tools.  You will be able to use fancy tools later.


\subsection{To be completed in the lab}
\label{lab-edit-compile-run:to-be-completed-in-the-lab}
The following is the code for a very well-known program, \emph{Hello,
World!}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{namespace} \PYG{n+nn}{Comp170}
\PYG{p}{\PYGZob{}}
   \PYG{k}{public} \PYG{k}{class} \PYG{n+nc}{Hello}
   \PYG{p}{\PYGZob{}}    
      \PYG{k}{public} \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hello World!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This program is deliberately simple, so you can type it into a text
editor (Emacs is recommended but your instructor may introduce you to
a different editor, subject to availability in the lab) quickly and become familiar with how
to create, edit, and save a program. Perform the following steps. (You
are free to deviate but may want to consider following the steps
religiously at least once to ensure you were successful.)
\begin{enumerate}
\item {} 
Open the text editor. This can usually be done from your
GUI's start menu.

\item {} 
Create a folder anywhere you like (e.g. in Documents) and name it
\code{hello}. (This can be done through the desktop shell
(e.g. Windows Explorer or Apple Finder.) As a general rule, we
recommend that you start any new programming project in its own
folder that is free of other folders/files. Clutter is a great
enemy of those who aspire to become good programmers.

\item {} 
When you start in Emacs, you are in what is known as \emph{scratch}
mode.  Typical of a sketchpad used by artists, this is where you
can start typing right away. You can now begin typing in the text
above. Keep in mind that the exact formatting is not important at
this stage; however, as we progress in this course, you'll \emph{want}
to pay attention to how your code is formatted. (With most text editors, it is
possible to reformat your code to make it \emph{beautiful}. More on
that later.)

\item {} 
Once you have entered the text, you will want to \emph{save} it, just
as if you were saving a file in your word processor. (In the Emacs
text editor, you use Control-x, Control-s. You will want to save
the file with the name \code{Hello.cs}. If you are using a graphical
text editor (like the case) then you will usually be able to save
from the File menu, much like you would do in a regular word
processor. Keep in mind, however, that you will eventually want to
learn the \emph{keyboard shortcuts} for your editor as much development
work in the real world happens from the command line and remote
terminal sessions (e.g. web and embedded systems development).

\item {} 
If all has gone well, you will now have a version of \emph{Hello,
World} in a file named \code{Hello.cs} in a folder named \code{hello}
(located in \code{Documents}).

\item {} 
Now we are going to learn how to compile this program. For this,
you will need to open a shell. On Linux and OS X, the shell is
opened by launching Terminal. On Windows, open a Mono Command
Prompt, as discussed above (or use one you left open).  Again to
find it:
\begin{itemize}
\item {} 
OS X: Applications -\textgreater{} Terminal (double click it)

\item {} 
Linux: Applications -\textgreater{} Terminal

\item {} 
Windows: Start Menu, search for Mono Command Line

\end{itemize}

\item {} 
Now you need to learn how to ``move around'' using the shell. The
command shell basically awaits user input and does whatever it is
told (and does nothing otherwise). You'll begin by using the ``cd''
command to change your working directory to where you saved
\code{Hello.cs}.  Note: Replace Dr. Thiruvathukals's login id gkt by
your login id.  Also note for Mac/Unix examples that his machine
is called macaroni.

If you did everything right, you can do this on Windows:

\begin{Verbatim}[commandchars=\\\{\}]
C:\PYGZbs{}Windows\PYGZbs{}System32\textgreater{} cd C:\PYGZbs{}users\PYGZbs{}gkt
C:\PYGZbs{}Users\PYGZbs{}gkt\textgreater{} cd Documents\PYGZbs{}hello
C:\PYGZbs{}Users\PYGZbs{}gkt\PYGZbs{}Documents\PYGZbs{}hello\textgreater{}
\end{Verbatim}

Mac/Linux:

\begin{Verbatim}[commandchars=\\\{\}]
\$ cd Documents/hello
\end{Verbatim}

\item {} 
If you are on OS X or Linux, you can list the directory using the
\code{ls} command. If the output you see here does not match, make
sure you are in the \code{hello} folder:

\begin{Verbatim}[commandchars=\\\{\}]
\$ ls

macaroni:hello gkt\$ ls
Hello.cs

\$ pwd
/Users/gkt/Documents/hello
\end{Verbatim}

\item {} 
If you're on Windows, can list the contents of the directory using
\code{dir}:

\begin{Verbatim}[commandchars=\\\{\}]
C:\PYGZbs{}Users\PYGZbs{}gkt\PYGZbs{}Documents\PYGZbs{}hello\textgreater{}dir
         Volume in drive C has no label.
         Volume Serial Number is 2C13-C918

         Directory of C:\PYGZbs{}Users\PYGZbs{}anh\PYGZbs{}Documents\PYGZbs{}hello

        01/16/2012  06:07 PM    \textless{}DIR\textgreater{}          .
        01/16/2012  06:07 PM    \textless{}DIR\textgreater{}          ..
        11/04/2011  08:20 PM               646 Hello.cs

        ...
\end{Verbatim}

\item {} 
If you are unable to see \code{Hello.cs} at this stage, you need to
go back and check all previous steps. It is entirely possible you
did not create the folder or save properly. If you think you
completed these steps, this is a good time to ask the instructor
or teaching assistant for help.

\item {} 
Assuming you are able to see \code{Hello.cs} in the \code{hello} folder,
we are now ready for \emph{the good stuff*\textasciitilde{}\textasciitilde{}the technical term we use
when we are about to learn something that we need to know how to
do *for life}. We're going to compile the \code{Hello.cs} program
into \code{Hello.exe} so we can run it. FYI, you should still be in
the Terminal/DOS window where we just listed the directory (this
works regardless of what OS you are using). Enter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{gmcs} \PYG{n}{Hello}\PYG{p}{.}\PYG{n}{cs}
\end{Verbatim}

\item {} 
If everything worked right, you will not see any output. If you
spot any error messages, it means that you probably made a typo
when copying/typing the sample code into the text editor. Go back
to step @EditHello and check that everything is typed
properly. (We will not be discussing all the possible errors you
an encounter at this stage, but you might find them helpful to
edit your program.) If your text editor is not still open, then
you need to re-open the file, which can be done easily by using
File \code{-\textgreater{}} Open and browsing your folder structure to find folder
\code{hello}, then \code{Hello.cs}.

\item {} 
Now for the great moment you have been awaiting: You can \emph{run}
\code{Hello.exe}.  Enter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mono} \PYG{n}{Hello}\PYG{p}{.}\PYG{n}{exe}
\end{Verbatim}

You should see the result:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Hello}\PYG{p}{,} \PYG{n}{World}\PYG{p}{!}
\end{Verbatim}

\end{enumerate}

At this point, we have accomplished the major objective for Lab 0: to
enter, compile, and run a C\# program. In the next lab, we will work on
some revisions to \code{Hello.cs} to personalize it a bit.

As this point, you should grab the instructor or teaching assistant so
they can perform a quick inspection of your work and check it off. Per
the syllabus, labs are not graded but do need to be completed to receive
credit. If you are unable to make class on a lab day, please make sure
that you complete the work and demonstrate it by the beginning of the
next lab.


\subsection{For further reinforcement}
\label{lab-edit-compile-run:for-further-reinforcement}\begin{enumerate}
\item {} 
Download and install the Emacs and Mono Software Development Kit on
your home computer or laptop.

\item {} 
Make sure you can do everything that you just completed in the lab.

\item {} 
See whether you can get a head start on Lab 1.

\end{enumerate}


\subsection{Some Useful Resources for Learning Emacs}
\label{lab-edit-compile-run:some-useful-resources-for-learning-emacs}\begin{enumerate}
\item {} 
The GNU Emacs Tutorial, \href{http://www.gnu.org/software/emacs/tour/}{http://www.gnu.org/software/emacs/tour/}

\item {} 
University of Chicago Libraries Emacs Tutorial,
\href{http://www2.lib.uchicago.edu/keith/tcl-course/emacs-tutorial.html}{http://www2.lib.uchicago.edu/keith/tcl-course/emacs-tutorial.html}

\end{enumerate}


\subsection{Other Useful Text Editors}
\label{lab-edit-compile-run:other-useful-text-editors}
\#. Gedit, \href{http://gedit.org}{http://gedit.org}, is a very nice editor that comes with most
Linux/Gnome distributions. Although it allegedely runs on Windows and OS X, we
have not had a chance to test it and cannot recommend it at this time.
\begin{enumerate}
\item {} 
Vim,  \href{http://www.vim.org/docs.php}{http://www.vim.org/docs.php}, is another popular editor based
on the famous \textbf{vi} text editor that goes back a number of
decades. There are graphical versions for Linux, Mac, and Windows.

\end{enumerate}

Unfortuntely, these are not available in the Windows labs yet (unlike
Emacs); however, students working in the Linux laboratory have access
to these editors and may wish to learn them.


\subsection{What's next in Lab 1?}
\label{lab-edit-compile-run:what-s-next-in-lab-1}
We'll continue learning more about C\#. The next lab will give you
exposure to the C\# interactive mode (in Mono, the \code{csharp} command),
where we will learn to work with arithmetic and basic primitive types.
The \code{csharp} command allows you to use C\# as a sort of ``toy
calculator'' language. It also allows you to test capabilities of the C\#
\emph{programming library}. For example, we will learn some other things you
can do with the \code{Console} interfaces, including how to prompt a user
for input.


\section{Comments on Miles Simple Data}
\label{milessimpledata:comments-on-miles-simple-data}\label{milessimpledata::doc}
Miles Chapter 2 on Simple Data Processing is also well written.  As you \emph{read it},
note the specific comments below.   The chapter does not mention the Mono tool,
csharp, which makes it very easy to test simple data operations.
\begin{description}
\item[{Page 27}] \leavevmode
The table is for reference, context, and completeness:
You do NOT need to memorize all the types, particularly now!
Mostly used are int and char, and possibly long for really big numbers.

\item[{Page 28}] \leavevmode
We will mostly stick to double for convenience.
Using smaller versions is only important if you have enormous collections of data.
You do not need to use the E notation – though you may see it.

\item[{Page 29}] \leavevmode
This is another table for reference/completeness.
The only escape code we are likely to use are \textbackslash{}n, \textbackslash{}\textbackslash{}, \textbackslash{}''.

\item[{Page 30}] \leavevmode
Unicode is nice if you want different languages and special symbols, but we will not use it.

\item[{Page 33}] \leavevmode
The precedence table is very misleading:
It does not distinguish operands with the SAME precedence:
Operators * and /, have the same precedence.
The binary operations + and - have the same precedence.

This is the same precedence as in normal math.  See the related section added below
about another useful operator related to division, the remainder operator, \%.
It has the same precedence as * and /.

\item[{Page 34-35:}] \leavevmode
The idea of casting numbers is important,
that the same abstract number may have different representations,
and some are more or less accurate.
In practice the main cast for us will be int to double.
Make sure you realize that casting double to int is NOT the same as rounding; instead
it removes the fractional part whether high, .999, low, 0.1, or in the middle, .5.

\end{description}

\index{division!remainder}\index{remainder!division}

\section{Division and Remainders}
\label{remainders:index-0}\label{remainders::doc}\label{remainders:division-and-remainders}\label{remainders:id1}
Try in the csharp shell.  Be sure to include the decimal points:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{5.0}\PYG{p}{/}\PYG{l+m}{2.0}\PYG{p}{;}
\PYG{l+m}{1}\PYG{l+m}{4.0}\PYG{p}{/}\PYG{l+m}{4.0}\PYG{p}{;}
\end{Verbatim}

On the other hand, try in csharp:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{4}\PYG{p}{/}\PYG{l+m}{4}\PYG{p}{;}
\end{Verbatim}

you get something that looks strange:  Just and addition, subtraction, and multiplication
of \code{int}s produces and \code{int}, so, too with division.

In C\#, the result of the / operator depends on the
type of the operands, not on the mathematical value of the operands.

If you think about it, you learned several ways to do division.
Eventually you learned how to do division resulting in a decimal.
In the earliest grades you would say
\begin{quote}

``14 divided by 4 is 3 with a remainder of 2''.
\end{quote}

Note the the quotient is an integer 3, that matches the C\# evaluation of 14/4,
so having a way to generate an integer quotient is not actually too strange.
The problem here is
that the answer from grade school is in two parts, the integer quotient 3 and the
remainder 2.

C\# has separate operation to generate the remainder part.  There is no standard
single operator character operator in regular math, so C\# grabs an unused symbol
(the same ias in many other computer languages): \% is the remainder operator.

Try in the csharp shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{4}\PYG{p}{\PYGZpc{}}\PYG{l+m}{4}\PYG{p}{;}
\end{Verbatim}

You see you do get the remainder from our grade school division.

Now predict and then try each in the csharp shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{2}\PYG{l+m}{3}\PYG{p}{/}\PYG{l+m}{5}\PYG{p}{;}
\PYG{l+m}{2}\PYG{l+m}{3}\PYG{p}{\PYGZpc{}}\PYG{l+m}{5}\PYG{p}{;}
\PYG{l+m}{2}\PYG{l+m}{0}\PYG{p}{\PYGZpc{}}\PYG{l+m}{5}\PYG{p}{;}
\PYG{l+m}{6}\PYG{p}{/}\PYG{l+m}{8}\PYG{p}{;}
\PYG{l+m}{6}\PYG{p}{\PYGZpc{}}\PYG{l+m}{8}\PYG{p}{;}
\PYG{l+m}{6.0}\PYG{p}{/}\PYG{l+m}{8}\PYG{p}{;}
\end{Verbatim}

The / operator can be confusing, depending on the type, not the mathematical value.
Note that if at least one operand is double, the result was be.

Finding remainders will prove more useful than you might think in
the future!


\subsection{Exercise for Quotients}
\label{remainders:quotientproblem}\label{remainders:exercise-for-quotients}
Write a program, \code{quotient.cs}, that
prompts the user for two integers, and then prints them out in a
sentence with an integer division problem like

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{quotient} \PYG{n}{of} \PYG{l+m}{1}\PYG{l+m}{4} \PYG{n}{and} \PYG{l+m}{3} \PYG{k}{is} \PYG{l+m}{4} \PYG{n}{with} \PYG{n}{a} \PYG{n}{remainder} \PYG{n}{of} \PYG{l+m}{2}
\end{Verbatim}


\section{Substitutions in Console.WriteLine}
\label{writeline-substitution:substitutions-in-console-writeline}\label{writeline-substitution::doc}

\subsection{Output With \texttt{+}}
\label{writeline-substitution:output-with}
An elaboration of a ``Hello, World'' program, could greet the user,
after obtaining the user's name.  If the user enters thje name
Kim, the program could print
\begin{quote}

Hello, Kim!
\end{quote}

This is a very simple
input-process-output program (in fact with almost no ``process'').
Think how would you code it?

You need to obtain a name, remember it and use it in your output.
A solution is in the next section.

\index{WriteLine!\{\} for format}\index{\{\} for format!WriteLine}

\subsection{String Format Operation}
\label{writeline-substitution:index-0}\label{writeline-substitution:string-format-operation}\label{writeline-substitution:format-strings}
A common convention is fill-in-the blanks. For instance,
\begin{quote}

Hello, \_\_\_\_\_!
\end{quote}

and you can fill in the name of the person greeted, and combine
given text with a chosen insertion. C\# has a similar
construction, better called fill-in-the-braces,
that can be used with \code{Console.WriteLine}.

Instead of inserting user input with the \code{+} operation as in
\code{HelloYou1.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{HelloYou1}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"What is your name?"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{name} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hello, "} \PYG{p}{+} \PYG{n}{name} \PYG{p}{+} \PYG{l+s}{"!"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

look at a variation, \code{HelloYou2.cs}, shown below.
Both programs
look exactly the same to the user:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{HelloYou}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"What is your name?"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{name} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hello, \PYGZob{}0\PYGZcb{}!"}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\code{Console.WriteLine} actually can take parameters \emph{after} an initial string,
but only when  the string is in the form of a \emph{format string},
with expression(s) in braces where substitutions are to be made,
(like in fill-in-the-blanks).

The remaining parameters, after the initial string,
give the values to be substituted.  To
know \emph{which} further parameter to substitute, the parameters after the
initial string are implicitly numbered,
\emph{starting from 0}.
Starting with 0 is consistent with other numbering sequences in C\#.
So here, where there is just one value to substitute, it gets the index 0,
and where it is substituted, the braces get 0 inside, to indicate
that parameter 0 is to be substituted.

Everything in the initial string that is \emph{outside} the braces is just
repeated verbatim.  In particular, if the only parameter is a string
with no braces, it is printed completely
verbatim (as we have used \code{Console.WriteLine} before).

A more elaborate silly examples that you could test in csharp would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string} \PYG{n}{first} \PYG{p}{=} \PYG{l+s}{"Peter"}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{last} \PYG{p}{=} \PYG{l+s}{"Piper"}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{what} \PYG{p}{=} \PYG{l+s}{"pick"}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{}, \PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{}, \PYGZob{}2\PYGZcb{}."}\PYG{p}{,} \PYG{n}{first}\PYG{p}{,} \PYG{n}{last}\PYG{p}{,} \PYG{n}{what}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

It would print:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Peter} \PYG{n}{Piper}\PYG{p}{,} \PYG{n}{Peter} \PYG{n}{Piper}\PYG{p}{,} \PYG{n}{pick}\PYG{p}{.}
\end{Verbatim}

where parameter 0 is \code{first} (value \code{"Peter"}),
parameter 1 is \code{last} ( value \code{"Piper"}), and
parameter 2 is \code{what} (value \code{"pick"}).

Make sure you see why the given output is exactly what is printed.

Or try in csharp:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{7}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{y} \PYG{p}{=} \PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} plus \PYGZob{}1\PYGZcb{} = \PYGZob{}2\PYGZcb{}; \PYGZob{}0\PYGZcb{} times \PYGZob{}1\PYGZcb{} = \PYGZob{}3\PYGZcb{}."}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{+}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{*}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and see it print:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{7} \PYG{n}{plus} \PYG{l+m}{5} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{2}\PYG{p}{;} \PYG{l+m}{7} \PYG{n}{times} \PYG{l+m}{5} \PYG{p}{=} \PYG{l+m}{3}\PYG{l+m}{5.}
\end{Verbatim}

Note the following features:
\begin{itemize}
\item {} 
Parameters can be any expression,
and the expressions get evaluated before printing.

\item {} 
Parameters to be substituted can be of any type.

\item {} 
The parameters are automatically converted to a string form, just as in the
use of the string \code{+} operation.

\end{itemize}

In fact the simple use of format strings
shown so far can be completed replaced by long expressions with \code{+},
if that is your taste.  Miles later (on page 50) discusses fancier formatting,
that \emph{cannot} be duplicated with a simple string \code{+} operation.
We will just use the simple numbered substitutions for now,
to get used to the idea of substitution.

A technical point: Since braces have special meaning in a format
string, there must be a special rule if you want braces to actually
be included in the final \emph{formatted} string. The rule is to double
the braces: \code{'\{\{'} and \code{'\}\}'}. The fragment

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{,} \PYG{n}{b} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"The set is \PYGZob{}\PYGZob{}\PYGZob{}0\PYGZcb{}, \PYGZob{}1\PYGZcb{}\PYGZcb{}\PYGZcb{}."}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

produces

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{k}{set} \PYG{k}{is} \PYG{p}{\PYGZob{}}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{.}
\end{Verbatim}
\phantomsection\label{learning-to-problem-solve:learn-solve}
\index{problem solving!strategy}

\section{Learning to Solve Problems}
\label{learning-to-problem-solve:index-0}\label{learning-to-problem-solve::doc}\label{learning-to-problem-solve:learning-to-solve-problems}
\begin{notice}{note}{Todo}

Andy new
\end{notice}

\index{labs!division sentences}

\section{Lab: Division Sentences}
\label{lab-division-sentences:index-0}\label{lab-division-sentences::doc}\label{lab-division-sentences:lab-division-sentences}
\begin{notice}{note}{Todo}

George

emacs java mode, csharp mode, Windows install csharp mode

14 / 4 is approximately 3.5.

14/4 = 3 2/4

will improve ``2/4'' later....
\end{notice}


\chapter{Defining Functions of your Own}
\label{functions:defining-functions-of-your-own}\label{functions::doc}\label{functions:defining-own-functions}
\index{syntax template!typography}\index{typography!syntax template}

\section{Syntax Template Typography}
\label{typography:syntax-template-typography}\label{typography:index-0}\label{typography::doc}\label{typography:id1}
When new C\# syntax is introduced, the usual approach will be to
give both specific examples and general templates. In general
templates for C\# syntax the typeface indicates the the category
of each part:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
Typeface
} & \textbf{
Meaning
}\\\hline

\code{Typewriter font}
 & 
Text to be written \emph{verbatim}
\\\hline

\emph{Emphasized}
 & 
A place where you can use an arbitrary
expression.
\\\hline

\textbf{Bold}
 & 
A place where you can use an arbitrary
identifier.
\\\hline

Normal text
 & 
A description of what goes in that position,
without giving explicit syntax
\\\hline
\end{tabulary}


An attempt is made with the parts that are not verbatim to be
descriptive of the use expected.

We will use these conventions shortly in the discussion of function
syntax, and will continue to use the conventions throughout the
notes.

\index{function!definition}\index{definition!function}

\section{A First Function Definition}
\label{firstfunc:index-0}\label{firstfunc::doc}\label{firstfunc:a-first-function}\label{firstfunc:a-first-function-definition}
If you know it is the birthday of a friend, Emily, you might tell
those gathered with you to sing ``Happy Birthday to Emily''.

We can make C\# display the song. \emph{Read}, and run if you like,
the example program \code{birthday1.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday1}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Emily."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Here the song is just a part of the \code{Main} method that is in
every program.

Note that we are using a function already provided to us,
\code{Console.WriteLine}.  We can use it over and over, wherever we like.
We can alter its behavior by including a different parameter.
Now we look further at writing and using your own functions.

If we
want this song to be just part of a larger program, and be able to refer
to it repeatedly and easily, we might like
to package it separately.
You would probably not repeat the whole song to let others know
what to sing. You would give a request to sing via a descriptive
name like ``Happy Birthday to Emily''.

In C\# we can also give a name like \code{happyBirthdayEmily}, and
associate the name with whole song by using a new
\emph{function definition}, also called a \emph{method}. We will see many variations
on method definitions.  Later we will see definitions that are
attached to a particular object.
For now the simpler cases do not involve creating a type of object,
but there is an extra word needed to distinguish a function definition
\emph{not} attached to  on object, \code{static}.
We will also shortly look at functions more like
the functions from math class, that produce or \emph{return} a value.  In
this simple case we will not deal with returning a value.
This also requires a special word in the heading:  \code{void}.  A \code{void}
function will just be a shorthand name for something to do, a procedure
to follow, in this case
printing out the Happy Birthday song for Emily.  (Note that
the \code{Main} method for a program is also \code{static void}.
This \emph{does} your whole program and is not attached to an object.)

\emph{Read} for now:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday2}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Emily."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}   
      \PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hip hip hooray!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

There are several parts of the syntax for a function definition to
notice:

Line 5: The \emph{heading} starts with \code{static void}, the name of the function,
and then parentheses.  A more general syntax for functions that just \emph{do}
something is
\begin{quote}

\code{static void} \textbf{function\_name}\code{()}
\end{quote}

Lines 6-11: The remaining lines form the function \emph{body}.  They are enclosed
in braces.  By convention the lines inside the braces are indented by a
consistent amount. Four spaces is common indentation.

The whole definition does just that: \emph{defines} the meaning of the
name \code{happyBirthdayEmily}, but it does not do anything else yet -
for example, the definition itself does not make anything be
printed yet. This is our first example of altering the order of
execution of statements from the normal sequential order. This is
important: the statements in the function \emph{definition} are \emph{not}
executed as C\# first passes over the lines.
The only part of a program that is automatically executed is \code{Main}.
Hence \code{Main} better refer to the newly defined function....

Look at the first statement inside Main, line 15:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Note that the \code{static void} of the function definition is missing,
but we still have the function name and parentheses.
C\# goes back and looks up
the definition, and only then, executes the code inside the
function definition. The term for this action is a \emph{function call}
or function \emph{invocation}.  In this simple situation the format is
\begin{quote}

\emph{function\_name}\code{()}
\end{quote}

Can you predict what the program will do?  Note the two function calls
to \code{happyBirthdayEmily}.  To see, load and run \code{birthday2.cs}.

\index{function!execution sequence}\index{execution!sequence, function}\index{sequence!function execution}
The \emph{execution} sequence for the program is different from the
\emph{textual} sequence.  Execution always starts in Main:
\begin{enumerate}
\item {} 
Line 13: Main is where execution starts, and initially proceeds
sequentially.

\item {} 
Line 15: the function is called while this location is
remembered.

\item {} 
Lines 5-11: Jump!  The code of the function is executed for the first
time, printing out the song.

\item {} 
End of line 15: Back from the function call. continue on.

\item {} 
Line 16:  Just to mix things up, print out a ``Hip, hip, hooray''.

\item {} 
Line 17: the function is called again while this location is
remembered.

\item {} 
Lines 5-11: The function is executed again, printing out the song
again.

\item {} 
End of line 17: Back from the function call, but at this point
there is nothing more in \code{Main}, and execution stops.

\end{enumerate}

Functions alter execution order in several ways: by statements not
being executed as the definition is first read, and then when the
function is called during execution, jumping to the function code,
and back at the the end of the function execution.

If it also happens to be Andre's birthday, we might define a
function \code{happyBirthdayAndre}, too. Think how to do that before
going on ....


\section{Multiple Function Definitions}
\label{multfunc::doc}\label{multfunc:multiple-function-definitions}\label{multfunc:id1}
Here is example program \code{birthday3.cs} where we add a function
\code{happyBirthdayAndre}, and call them both. Guess what happens, and
then load and try it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday3}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}   
       \PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
       \PYG{n}{happyBirthdayAndre}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Emily."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthdayAndre}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}   
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Andre."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Again, definitions are remembered and execution starts in \code{Main}.
The order in which the function definitions are given does not matter
to C\#.  It is a human choice.  For variety I show \code{Main} first.  This
means a human reading in order gets an overview of what is happening
by looking at Main, but does not know the details until reading the
definitions of the birthday functions.

Detailed order of execution:
\begin{enumerate}
\item {} 
Line 5: Start on \code{Main}

\item {} 
Line 7. This location is remembered as execution jumps to
\code{happyBirthdayEmily}

\item {} 
Lines 11-17 are executed and Emily is sung to.

\item {} 
Return to the end of Line 7: Back from \code{happyBirthdayEmily}
function call

\item {} 
Line 8: Now \code{happyBirthdayAndre} is called as this location is
remembered.

\item {} 
Lines 19-25: Sing to Andre

\item {} 
Return to the end of line 8: Back from \code{happyBirthdayAndre}
function call, done with \code{Main};
at the end of the program

\end{enumerate}

The calls to the birthday functions
\emph{happen} to be in the same order as their definitions, but that is
arbitrary. If the two lines of the body of \code{Main} were swapped,
the order of
operations would change.

Functions that you write can also call other functions you write.
In this case Main calls each of the birthday functions.


\subsection{Poem Function Exercise}
\label{multfunc:poem-function-exercise}
Write a program, \code{poem.cs}, that defines a function that
prints a \emph{short} poem or song verse. Give a meaningful name to the
function. Have the program call the function three times,
so the poem or verse is repeated three times.

\index{function!parameters}\index{parameters!function}

\section{Function Parameters}
\label{funcparam:index-0}\label{funcparam::doc}\label{funcparam:function-parameters}\label{funcparam:id1}
As a young child, you probably heard Happy Birthday sung to a
couple of people, and then you could sing to a new person, say
Maria, without needing to hear the whole special version with
Maria's name in it word for word. You had the power of
\emph{abstraction}. With examples like the versions for Emily and Andre,
you could figure out what change to make it so the song could be
sung to Maria!

Unfortunately, C\# is not that smart. It needs explicit rules.
If you needed to explain \emph{explicitly} to someone how Happy Birthday
worked in general, rather than just by example, you might say
something like this:

First you have to be \emph{given} a person's name. Then you sing the
song with the person's name inserted at the end of the third line.

C\# works something like that, but with its own syntax. The term
``person's name'' serves as a stand-in for the actual data that
will be used, ``Emily'', ``Andre'', or ``Maria''. This is just like
the association with a variable name in C\#. ``person's name''
is not a legal C\# identifier, so we will use just \code{person} as
this stand-in.  It will be a variable in the program,
so it needs a type in C\#.  The names are strings,
so the type of \code{person} is \code{string}.

The function definition indicates that the variable name \code{person}
will be used inside the function by inserting it between the
parentheses of the definition, preceeded by its type.
Then in the body of the definition
of the function, person is used in place of the real data for any
specific person's name. Read and then run example program
\code{birthday4.cs}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday4}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthday}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{person}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear "} \PYG{p}{+} \PYG{n}{person} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{happyBirthday}\PYG{p}{(}\PYG{l+s}{"Emily"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{happyBirthday}\PYG{p}{(}\PYG{l+s}{"Andre"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

In the definition heading for \code{happyBirthday}, \code{person} is
referred to as a \emph{parameter}, or a \emph{formal parameter}. This
variable name is a \emph{placeholder} for the real name of the person
being sung to.

Main now has two calls to the same function,
but between the parentheses, where there was the palceholder \code{person}
in the definition, now we have the actual people being sung to.
The value between the parentheses here in the function call
is referred to as an \emph{argument} or \emph{actual parameter} of the
function call. The argument supplies the actual data to be used in
the function execution. When the call is made, C\# does this by
associating the formal parameter name \code{person} with the actual
parameter data, as in an assignment statement. In the first call,
this actual data is \code{'Emily'}. We say the actual parameter value
is \emph{passed} to the function.

The execution in greater detail:
\begin{enumerate}
\item {} 
Lines 13: Execution starts in Main.

\item {} 
Line 15: Call to \code{happyBirthday}, with actual parameter
\code{'Emily'}.

\item {} 
Line 5: \code{'Emily'} is passed to the function, so
\code{person = 'Emily'}.

\item {} 
Lines 7-10: The song is printed, with \code{'Emily'} used as the
value of \code{person} in line 9: printing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Happy} \PYG{n}{Birthday}\PYG{p}{,} \PYG{n}{dear} \PYG{n}{Emily}\PYG{p}{.}
\end{Verbatim}

\item {} 
End of line 15 after returning from the function call

\item {} 
Line 16: Call to \code{happyBirthday}, this time with actual
parameter \code{'Andre'}

\item {} 
Line 5: \code{'Andre'} is passed to the function, so
\code{person = 'Andre'}.

\item {} 
Lines 7-10: The song is printed, with \code{'Andre'} used as the
value of \code{person} in line 9: printing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Happy} \PYG{n}{Birthday}\PYG{p}{,} \PYG{n}{dear} \PYG{n}{Andre}\PYG{p}{.}
\end{Verbatim}

\item {} 
End of line 16 after returning from the function call,
and the program is over.

\end{enumerate}

The beauty of this system is that the same function definition can
be used for a call with a different actual parameter variable, and
then have a different effect. The value of the variable person is
used in the third line of \code{happyBirthday}, to put in whatever
actual parameter value was given.

\index{abstraction}
This is the power of \emph{abstraction}. It is one application of the
most important principal in programming. Rather than have a number
of separately coded parts with only slight variations, see where it
is appropriate to combine them using a function whose parameters
refer to the parts that are different in different situations. Then
the code is written to be simultaneously appropriate for the
separate specific situations, with the substitutions of the right
parameter values.

\begin{notice}{note}{Note:}
Be sure you completely understand \code{birthday4.cs}
and the sequence of execution!  It illustrates extremely
important ideas that many people miss the first time!  It is
essential to understand the difference between
\begin{enumerate}
\item {} 
\emph{Defining} a function (lines 5-11)
with the heading including \emph{formal} parameter name and type,
where the code is merely instructions to be remembered,
not acted on immediately.

\item {} 
\emph{Calling} a function with an \emph{actual} paramerer value to be
substituted for the formal parameter,
(with \emph{no} type included!) and have the function
code actually \emph{run} when the instruction containing the call
is run.  Also note that the function can be
called multiple times with different expressions as the
actual parameter (line 15 and again in line 16).

\end{enumerate}
\end{notice}

We can combine function parameters with user input, and have the
program be able to print Happy Birthday for anyone. Check out the
main method and run \code{birthday\_who.cs}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday\PYGZus{}Who}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthday}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{person}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear "} \PYG{p}{+} \PYG{n}{person} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{userName}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Who would you like to sing Happy Birthday to?"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{userName} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{happyBirthday}\PYG{p}{(}\PYG{n}{userName}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This last version illustrates several important ideas:
\begin{enumerate}
\item {} 
There are more than one way to get information into a function:
\begin{enumerate}
\item {} 
Have a value passed in through a parameter (from line 18 to line 5).

\item {} 
Prompt the user, and obtain data from the keyboard (lines 16-17).

\end{enumerate}

\item {} 
It is a good idea to separate the \emph{internal} processing of data
from the \emph{external} input from the user by the use of distinct
functions. Here the user interaction is in \code{main}, and the data
is manipulated in \code{happyBirthday}.

\item {} 
In the first examples of actual parameters, we used literal
values. In general an actual parameter can be an expression. The
expression is evaluated before it is passed in the function call.
One of the simplest expressions is a plain variable name, which is
evaluated by replacing it with its associated value. Since it is
only the value of the actual parameter that is passed, not any
variable name, there is \emph{no need} to have a variable name used in
an actual parameter match a formal parameter name. (Here we have the
value of \code{userName} in \code{main} becoming the value of \code{person}
in \code{happyBirthday}.)

\end{enumerate}


\subsection{Birthday Function Exercise}
\label{funcparam:birthdayfunctionex}\label{funcparam:birthday-function-exercise}
Make your own further change to \code{birthday4.cs} and save it as
\code{birthdayMany.cs}: Add a function call
(but \emph{not} another function \emph{definition}), so Maria gets a verse, in
addition to Emily and Andre. Also print a blank line between
verses. (There ae two ways to handle the blank lines:
You may \emph{either} do this by adding a print line to the
function definition, \emph{or} by adding a print line between all calls to
the function.  Recall that if you give Console.WriteLine an empty
parameter list, it just goes to the next line.)

\index{function!parameter}\index{parameter!function}

\section{Multiple Function Parameters}
\label{funcparam2:index-0}\label{funcparam2:multiple-function-parameters}\label{funcparam2::doc}
A function can have more than one parameter in a parameter list
separated by commas. Each formal parameter name is preceded by its type.
For example the example program \code{addition1.cs}
uses
a function to make it easy to display many sum problems. Read and
follow the code, and then run:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Addition1}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{sumProblem}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{sum} \PYG{p}{=} \PYG{n}{x} \PYG{p}{+} \PYG{n}{y}\PYG{p}{;}
      \PYG{k+kt}{string} \PYG{n}{sentence} \PYG{p}{=} \PYG{l+s}{"The sum of "} \PYG{p}{+} \PYG{n}{x} \PYG{p}{+} \PYG{l+s}{" and "} \PYG{p}{+} \PYG{n}{y} \PYG{p}{+} \PYG{l+s}{" is "} \PYG{p}{+} \PYG{n}{sum} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sentence}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{sumProblem}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{3}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sumProblem}\PYG{p}{(}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{p}{,} \PYG{l+m}{5}\PYG{l+m}{3}\PYG{l+m}{5}\PYG{l+m}{7}\PYG{l+m}{9}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter an integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter another integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sumProblem}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\index{parameter!actual}\index{actual!parameter}\index{parameter!formal}\index{formal!parameter}
The actual parameters in the function call are evaluated left to
right, and then these values are associated with the formal
parameter names in the function definition, also left to right. For
example a function call with actual parameters,
\code{f(actual1, actual2, actual3)}, calling a function \code{f} with
definition heading:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{formal1}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{formal2}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{formal3}\PYG{p}{)}
\end{Verbatim}

acts approximately as if the first lines executed inside the called
function \code{f} were

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{formal1} \PYG{p}{=} \PYG{n}{actual1}\PYG{p}{;}
\PYG{n}{formal2} \PYG{p}{=} \PYG{n}{actual2}\PYG{p}{;}
\PYG{n}{formal3} \PYG{p}{=} \PYG{n}{actual3}\PYG{p}{;}
\end{Verbatim}

Functions provide extremely important functionality to programs,
allowing tasks to be defined once and performed repeatedly with
different data. It is essential to see the difference between the
\textbf{formal} parameters used to describe what is done inside the function
definition (like x and y in the definition of sumProblem) and the
\textbf{actual} parameters (like 2 and 3 or 12345 and 53579)
which \emph{substitute} for the formal parameters when the function is
actually executed. \code{Main} uses three different sets
of actual parameters in the three calls to sumProblem.


\subsection{Quotient Function Exercise}
\label{funcparam2:quotient-function-exercise}\label{funcparam2:quotientfunctionex}
Modify \code{quotient.cs{}`from
:ref:{}`QuotientProblem} and save it
as \code{quotientProb.cs}.
You should create a function \code{quotientProblem} with int
parameters.  Like in the earlier versions, it should print a full
sentence with inputs, quotient, and remainder.
\code{Main}
should test the \code{quotientProblem} function
on several sets of literal values, and also test the function with
input from the user.

\index{function!return math}\index{return!math, function}\index{math!function return}\index{function!sequence}\index{sequence!function}

\section{Returned Function Values}
\label{funcreturn:returned-function-values}\label{funcreturn:index-0}\label{funcreturn::doc}\label{funcreturn:id1}
You probably have used mathematical functions in algebra class, but
they all had calculated values associated with them. For instance
if you defined
\begin{quote}

f(x)=x$^{\text{2}}$
\end{quote}

then it follows that f(3) is 3$^{\text{2}}$, and f(3)+f(4) is
3$^{\text{2}}$ + 4$^{\text{2}}$

Function calls in expressions get
replaced during evaluation by the value of the function.

The corresponding definition and examples in C\# would be the
following, taken from example program \code{return1.cs}. \emph{Read}
\emph{and run}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Return1}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
       \PYG{k}{return} \PYG{n}{x}\PYG{p}{*}\PYG{n}{x}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)} \PYG{p}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The new C\# syntax is the \emph{return statement}, with the word
\code{return} followed by an expression. Functions that return values
can be used in expressions, just like in math class. When an
expression with a function call is evaluated, the function call is
effectively replaced temporarily by its returned value. Inside the
C\# function, the value to be returned is given by the
expression in the \code{return} statement.

Since the function returns data, and all data in C\# is typed,
there must be a type given for the value returned.  Note that the
function heading does not start with \code{static void}.
In place of \code{void} is \code{int}.  The \code{void} in earlier function headings
meant nothing was returned.  The \code{int} here means that a value \emph{is}
returned and its type is \code{int}.

After the function \code{f}
finishes executing from inside

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

it is as if the statement temporarily became

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and similarly when executing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)} \PYG{p}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

the interpreter first evaluates f(3) and effectively replaces the
call by the returned result, 9, as if the statement temporarily
became

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9} \PYG{p}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and then the interpreter evaluates f(4) and effectively replaces
the call by the returned result, 16, as if the statement
temporarily became

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9} \PYG{p}{+} \PYG{l+m}{1}\PYG{l+m}{6}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

resulting finally in 25 being calculated and printed.

\textbf{C\#} functions can return any type of data, not just numbers, and
there can be any number of statements executed before the return
statement. Read, follow, and run the example program
\code{return2.cs}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Return2}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{lastFirst}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{firstName}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{lastName}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{separator} \PYG{p}{=} \PYG{l+s}{", "}\PYG{p}{;}
      \PYG{k+kt}{string} \PYG{n}{result} \PYG{p}{=} \PYG{n}{lastName} \PYG{p}{+} \PYG{n}{separator} \PYG{p}{+} \PYG{n}{firstName}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{lastFirst}\PYG{p}{(}\PYG{l+s}{"Benjamin"}\PYG{p}{,} \PYG{l+s}{"Franklin"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{lastFirst}\PYG{p}{(}\PYG{l+s}{"Andrew"}\PYG{p}{,} \PYG{l+s}{"Harrington"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Many have a hard time following the flow of execution with functions.
Even more is involved when there are return vaues.
Make sure you completely follow the details of the execution:
\begin{enumerate}
\item {} 
Lines 12: Start at Main

\item {} 
Line 14: call the function, remembering where to return

\item {} 
Line 5: pass the parameters: \code{firstName = "Benjamin"};
\code{lastName = "Franklin"}

\item {} 
Line 7: Assign the variable \code{separator} the value \code{", "}

\item {} 
Line 8: Assign the variable \code{result} the value of
\code{lastName + separator + firstName} which is
\code{"Franklin" + ", " + "Benjamin"}, which evaluates to
\code{"Franklin, Benjamin"}

\item {} 
Line 9: Return \code{"Franklin, Benjamin"}

\item {} 
Line 14: Use the value returned from the function call so the line
effectively becomes  \code{Console.WriteLine("Franklin, Benjamin");},
so print it.

\item {} 
Line 15: call the function with the new actual parameters,
remembering where to return

\item {} 
Line 5: pass the parameters: \code{firstName = "Andrew"};
\code{lastName = "Harrington"}

\item {} 
Lines 7-9: ... calculate and return \code{"Harrington, Andrew"}

\item {} 
Line 15: Use the value returned by the function and print
\code{"Harrington, Andrew"}

\end{enumerate}

Compare \code{return2.cs} and \code{addition1.cs}, from the previous
section. Both use functions. Both print, but where the printing \emph{is
done} differs. The function \code{sumProblem} prints directly inside
the function and returns nothing explicitly. On the other hand
\code{lastFirst} does not print anything but returns a string. The
caller gets to decide what to do with the string, and above it is
printed in \code{Main}.

In general functions should do a single thing.
You can easily combine a sequence of functions, and you have more
flexibility in the combinations
if each does just one unified thing.  The function
sumProblem in \code{addition1.cs} does two thing:  It creates a sentence,
and prints it.  If that is all you have, you are out of luck if you want
to do something different with the sentence string.  A better way is
to have a functon that just creates the sentence, and returns it for
whatever further use you want.  After returning that value,
printing is one possibility, done in
\code{addition2.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Addition2}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{sumProblemString}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{sum} \PYG{p}{=} \PYG{n}{x} \PYG{p}{+} \PYG{n}{y}\PYG{p}{;}
      \PYG{k+kt}{string} \PYG{n}{sentence} \PYG{p}{=} \PYG{l+s}{"The sum of "} \PYG{p}{+} \PYG{n}{x} \PYG{p}{+} \PYG{l+s}{" and "} \PYG{p}{+} \PYG{n}{y} \PYG{p}{+} \PYG{l+s}{" is "} \PYG{p}{+} \PYG{n}{sum} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{sentence}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sumProblemString}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sumProblemString}\PYG{p}{(}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{p}{,} \PYG{l+m}{5}\PYG{l+m}{3}\PYG{l+m}{5}\PYG{l+m}{7}\PYG{l+m}{9}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter an integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter another integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sumProblemString}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Todo}

Put in utility functions for promted input
\end{notice}


\subsection{Quotient String Return Exercise}
\label{funcreturn:quotient-string-return-exercise}\label{funcreturn:quotientstringex}
Create \code{quotientReturn.cs} by modifying \code{quotientProb.cs} in
{\hyperref[funcparam2:quotientfunctionex]{\emph{Quotient Function Exercise}}} so that the program accomplishes the same
thing, but everywhere change the quotientProblem function into one
called \code{quotientString} that merely \emph{returns} the string rather
than printing the string directly. Have \code{Main} print
the result of each call to the \code{quotientString} function.

\index{function!consumer}\index{consumer!function}\index{function!writer}\index{writer!function}

\section{Two Roles: Writer and Consumer of Functions}
\label{writerconsumer:index-0}\label{writerconsumer:two-roles-writer-and-consumer-of-functions}\label{writerconsumer:two-roles}\label{writerconsumer::doc}
The remainder of this section covers finer
points about functions that you might skip on a first reading.

We are only doing tiny examples so far to get the basic idea of
functions. In much larger programs, functions are useful to manage
complexity, splitting things up into logically related, modest
sized pieces. Programmers are both writers of functions and
consumers of the other functions called inside their functions. It
is useful to keep those two roles separate:

The user of an already written function needs to know:
\begin{enumerate}
\item {} 
the name of the function

\item {} 
the order and meaning of parameters

\item {} 
what is returned or produced by the function

\end{enumerate}

\emph{How} this is accomplished is not relevant at this point. For
instance, you use the work of the C\# development team, calling
functions that are built into the language. You need know the three
facts about the functions you call. You do not need to know exactly
\emph{how} the function accomplishes its purpose.

On the other hand when you \emph{write} a function you need to figure
out exactly how to accomplish your goal, name relevant variables,
and write your code, which brings us to the next section.

\index{local!scope}\index{scope!local}

\section{Local Scope}
\label{localscope:local-scope}\label{localscope:index-0}\label{localscope::doc}\label{localscope:id1}
For the logic of writing functions, it is important that the writer
of a function knows the names of variables inside the function. On
the other hand, if you are only using a function, maybe written by
someone unknown to you, you should not care what names are given to
values used internally in the implementation of the function you
are calling. C\# enforces this idea with \emph{local scope} rules:
Variable names initialized and used inside one function are
\emph{invisible} to other functions. Such variables are called \emph{local}
variables. For example, an elaboration of the earlier program
\code{return2.cs} might have its \code{lastFirst} function with its local
variable \code{separator}, but it might also have another function
that defines a \code{separator} variable, maybe with a different value
like \code{"\textbackslash{}n"}. They would not conflict. They would be
independent. This avoids lots of errors!

For example, the following code in the example program
\code{badScope.cs} causes an execution error. Read it and try to run it, and
see:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{BadScope}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{;}
      \PYG{n}{f}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//ERROR f doesn't know about the x defined in Main}
   \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The error that Mono gives is pretty clear:
\begin{quote}

The name `x' does not exist in the current context.
\end{quote}

The context for \code{x} is the function \code{f}, not \code{Main}.
We will fix this error below.

If you do want local data from one function to go to another,
define the called function so it includes parameters! Read and
compare and try the program \code{goodscope.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{BadScope}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{;}
      \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

With parameter passing, the parameter name \code{x} in the function
\code{f} does not need to match the name of the actual parameter in
the calling function \code{Main}. The definition of \code{f} could just as well have been:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{whatever}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{whatever}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\index{global!constant}\index{constant!global}

\section{Static Variables}
\label{staticvariables:index-0}\label{staticvariables:static-variables}\label{staticvariables::doc}\label{staticvariables:id1}
You may define \emph{static variables} (variables defined inside the class,
but outside of any function definition).
These variables are visible inside all of your functions.
Instead of local scope, static variables have \emph{class scope}.
It is good programming practice generally to avoid defining static variables and
instead to put your variables inside functions and explicitly pass
them as parameters where needed. One common exception
will arise when we get to defining objects.  For now a
good reason for static variables is constants:
A \emph{constant} is a name that you give a fixed data value to.
You can then use the name of the fixed data value in
expressions anywhere in the class.
A simple example program is \code{constant.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Constant}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n}{PI} \PYG{p}{=} \PYG{l+m}{3.14159265358979}\PYG{p}{;} \PYG{c+c1}{// constant, value not reset}

   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{circleArea}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{radius}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{PI}\PYG{p}{*}\PYG{n}{radius}\PYG{p}{*}\PYG{n}{radius}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{circumference}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{radius}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{l+m}{2}\PYG{p}{*}\PYG{n}{PI}\PYG{p}{*}\PYG{n}{radius}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"circle area with radius 5: "} \PYG{p}{+} \PYG{n}{circleArea}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"circumference with radius 5:"} \PYG{p}{+} \PYG{n}{circumference}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

See that \code{PI} is used in two functions without being declared locally.

By convention, names for constants are all capital letters.
\phantomsection\label{notusereturn:string-char}
\index{function!scope not use return value}\index{scope!not use return value, function}\index{not use return value!function scope}

\section{Not using Return Values}
\label{notusereturn:index-0}\label{notusereturn::doc}\label{notusereturn:not-using-return-values}
\begin{notice}{note}{Todo}

Andy new
\end{notice}

\index{assignment!functions}

\section{Assignment: Functions}
\label{assignment-functions:index-0}\label{assignment-functions:assignment-functions}\label{assignment-functions::doc}
\begin{notice}{note}{Todo}

George

? tie into later work; good CS example?
\end{notice}


\chapter{Basic String Operations}
\label{basicstringops:basic-string-operations}\label{basicstringops::doc}\phantomsection\label{stringchar:string-char}
\index{string!char}\index{char!string}

\section{Strings and Characters}
\label{stringchar:index-0}\label{stringchar::doc}\label{stringchar:strings-and-characters}
\begin{notice}{note}{Todo}

Andy from Java version
\end{notice}
\phantomsection\label{stringindexing:string-char}
\index{string!char}\index{char!string}

\section{String Indexing}
\label{stringindexing:index-0}\label{stringindexing::doc}\label{stringindexing:string-indexing}
\begin{notice}{note}{Todo}

Andy from Java version
\end{notice}
\phantomsection\label{stringmethods:string-char}
\index{string!methods}

\section{String Methods}
\label{stringmethods:string-methods}\label{stringmethods:index-0}\label{stringmethods::doc}
\begin{notice}{note}{Todo}

Andy from Java version
\end{notice}
\phantomsection\label{problem-solving-replace:string-char}
\index{string!problem solving}\index{problem solving!string}

\section{A Creative Problem Solution}
\label{problem-solving-replace:index-0}\label{problem-solving-replace:a-creative-problem-solution}\label{problem-solving-replace::doc}
\begin{notice}{note}{Todo}

Andy from Java version
\end{notice}
\phantomsection\label{lab-string-ops:string-char}
\index{labs!string manipulations}

\section{Lab: String Operations}
\label{lab-string-ops:index-0}\label{lab-string-ops::doc}\label{lab-string-ops:lab-string-operations}
\begin{notice}{note}{Todo}

Andy from Java version
\end{notice}


\chapter{Decisions}
\label{decisions:decisions}\label{decisions::doc}

\section{Conditions}
\label{conditions:conditions}\label{conditions::doc}
Stub


\section{If-Statements}
\label{ifstatements:if-statements}\label{ifstatements::doc}
Stub


\chapter{Loops}
\label{loops:loops}\label{loops::doc}

\section{While-Statements}
\label{whilestatements::doc}\label{whilestatements:while-statements}
Stub


\section{For-Statements}
\label{forstatements:for-statements}\label{forstatements::doc}
Stub


\chapter{Arrays}
\label{arrays:arrays}\label{arrays::doc}

\section{One Dimensional Arrays}
\label{onedim:one-dimensional-arrays}\label{onedim::doc}
Stub


\section{Foreach Statements}
\label{foreach:foreach-statements}\label{foreach::doc}
Stub


\section{Two Dimensional Arrays}
\label{twodim::doc}\label{twodim:two-dimensional-arrays}
Stub


\chapter{Index and search}
\label{index:index-and-search}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}

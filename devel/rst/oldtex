% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Introductory Programming in C\#}
\date{January 22, 2012}
\release{1.0}
\author{Andrew N. Harrington and George K. Thiruvathukal}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Context}
\label{context:introductory-programming-in-c}\label{context::doc}\label{context:context}

\section{Introduction to the Notes}
\label{intro::doc}\label{intro:introduction-to-the-notes}
These notes are designed for Comp 170.  They are closely tied to the
excellent C\# introduction in Rob Miles' free online
\href{http://www.robmiles.com/c-yellow-book/Rob\%20Miles\%20CSharp\%20Yellow\%20Book\%202011.pdf}{C\# Yellow Book}.

These notes will follow mostly the same order, adding some extra explanations, examples,
and challenges, and introduce the Mono open source implementation of C\#.

The content here will be interspersed with comments about where to look at parts of Miles book,
with clarifications of the book and comments about what is not important for a
beginner in the book.

Computer programs are designed to run on a computer and solve problems.
Though the initial problems will be tiny and often silly, they will serve as learning tools
to prepare for substantive problems.


\section{Comments on Miles Chapter 1}
\label{milesintro:comments-on-miles-chapter-1}\label{milesintro::doc}
Miles Chapter 1 on Computers and Programs makes a good introduction and gives context.
\emph{Read} for the grounding it gives.

The chapter makes some reference to Microsoft,
the original creator of C\#, and its
Visual Studio software development environment, which works only on Windows machines,
and costs a lot if you are not a student.
The optional text by Lewis discussed Visual Studio at some length.
The next section of these notes will introduce an alternative to the
Microsoft environment: Mono, which is free,
open-source software that makes C\# available for multiple platforms:
Windows, Mac, or Linux machines.


\chapter{C\# Data and Operations}
\label{data::doc}\label{data:c-data-and-operations}

\section{Development Tools}
\label{monotools:development-tools}\label{monotools::doc}

\subsection{About Software Development Kits (SDKs)}
\label{monotools:about-software-development-kits-sdks}
A software development kit (SDK) is a set of tools for developing in a
particular programming language (in our class, C\#). Developing in a
language means everything from compiling to running and (when things
go wrong) to debugging programs.

The Microsoft SDK is the proprietary implementation of .Net. It runs
only on Windows and is the primary development framework for all
things Microsoft.

The Mono Project SDK \textless{}\href{http://mono-project.com}{http://mono-project.com}\textgreater{} is the free/open source
equivalent implementation of the Microsoft SDK. It runs on all major platforms (including Windows) and is needed in situations where you want to develop .Net applications on non-Windows platforms.

As an interesting aside, the company whose developers lead the work on
the Mono SDK are working on commercial tools that allow you to
develop/run applications written in .Net on Apple iOS and Android
mobile devices (phones and tablets).


\subsection{About Integrated Development Environments (IDE)}
\label{monotools:about-integrated-development-environments-ide}
While just about everything you need to create programs can, indeed,
be found in the SDK, it is not long before you wish there were an ``app
for that'' so to speak. While most programmers who developed code (like
your instructors) in the 1970s-1990s learned to program directly with
the SDK using the \emph{command line}, today's programmers largely to
prefer working in an IDE.

There are two major IDEs for .Net development, which we explain briefly below:
\begin{itemize}
\item {} 
Visual Studio is the Microsoft IDE that interfaces directly to the
Microsoft SDK.

\item {} 
MonoDevelop is the free/open source IDE for developing applications
using the Mono SDK on Windows and all other platforms (in
particular, Linux and OS X).

\end{itemize}

In addition, there is another Windows-specific IDE, SharpDevelop, that
inspired the creation of MonoDevelop. It is still actively maintained
and provides a somewhat ``lighter weight'' alternative to Visual Studio
for Windows users. Like MonoDevelop, it is aimed at developers who
would prefer a more free/open source ``friendly'' version.


\subsection{Our Approach}
\label{monotools:our-approach}
In the interest of providing a consistent experience for our students,
we will be using Mono (the SDK) and MonoDevelop (the IDE) for
everything we demonstrate in class. We will also be encouraging you to
use it for your work, especially if you are interested in
non-Microsoft platforms.

Our notes assume for the most part that you are working with Mono and
MonoDevelop. In most cases, what we are showing you in Mono and
MonoDevelop will translate almost \emph{as is} to the Microsoft
equivalents. However, there are some tools, such as the \code{csharp}
interpreter, that have a rough analog in Microsoft's tools but in a somewhat
limited form. As there is significant evolution of both the Microsoft
and Mono \emph{toolchains}--a fancy word we want you to know and a more
elegant way of saying SDK--we'll issue updates to these notes.


\subsection{Installing Mono}
\label{monotools:installing-mono}
Because the Mono Project web page is known to change frequently, these
instructions are designed to be as generic as possible. If you have
any questions, you should contact the intructors immediately or seek
tutoring help.


\subsection{OS X}
\label{monotools:os-x}\begin{enumerate}
\item {} 
Go to \textless{}\href{http://mono-project.com}{http://mono-project.com}\textgreater{}.

\item {} 
Look for the Mono downloads link. You want to get the latest \emph{stable}
version of Mono for OS X. For this class, you need version 2.10 or
later.

\item {} 
You may see a link to download \emph{Runtime} or \emph{SDK}. Make sure you select SDK.

\item {} 
For OS X, the SDK is distributed as a DMG disk image. You'll need
to download this image and double-click it. Open the image and run
the installer. Administrative privileges are required to run the
installer, so if you do not know this information, please stop
here.

\item {} 
Once installation is completed, you have everything needed to start
using the IDE, MonoDevelop.

\item {} 
Now go to \textless{}\href{http://mono-develop.com}{http://mono-develop.com}\textgreater{}.

\item {} 
As with Mono, we need to look for the downloads link.
You should download the \emph{stable} version.

\item {} 
As with Mono, you will see a DMG file,
which you should download and double-click to mount on your desktop.

\item {} 
This time, you will see an App for MonoDevelop,
which you can drag and drop into the Applications foldeer.

\end{enumerate}

Here is how to do a quick sanity check of your Mono setup:
\begin{enumerate}
\item {} 
Go to Applications -\textgreater{} Utilities and launch the Terminal
application. (Terminal is how you get to a command-line shell in OS X.)

\item {} 
You'll see a prompt that looks like this
\code{computername:folder user\$}.
This means that Terminal is ready for input.

\item {} 
Type \code{which csharp} and hit enter/return. You should see
\code{/usr/bin/csharp} as output. \code{csharp} is the C\# interpreter.

\item {} 
Type \code{which dmcs} and hit enter/return. You should see
\code{/usr/bin/dmcs} as output.  \code{dmcs} is one of the interfaces to
the C\# compiler.

\item {} 
If the two preceding steps were successful, you can launch
MonoDevelop by double-clicking the icon in your Applications
folder. (You won't know what to do with it yet, but at least you can
verify that it launches correctly and then use Command-Q to exit.)

\end{enumerate}


\subsection{Windows}
\label{monotools:windows}\begin{enumerate}
\item {} 
Go to \textless{}\href{http://mono-project.com}{http://mono-project.com}\textgreater{}.

\item {} 
Look for the Mono downloads link. You want to get the latest
\emph{stable} version of Mono for Windows. For this class, you need version
2.10 or later.

\item {} 
You may see a link to download \emph{Runtime} or \emph{SDK}. Make sure you select SDK.

\item {} 
For Windows, there is only one option to download the SDK. It is a
self-extracting executable, so you will need to double click it to
install. For Vista and 7 users, you may need to check your taskbar to
see whether the installer is being held up by Microsoft's enhanced
security, UAM, that makes sure you really want to install something
you downloaded from the internet.

\item {} 
Once installation is completed, you have everything needed to start
using the IDE, MonoDevelop.

\item {} 
Now go to \textless{}\href{http://mono-develop.com}{http://mono-develop.com}\textgreater{}.

\item {} 
As with Mono, we need to look for the downloads link. You should
download the \emph{stable} version.

\item {} 
As with Mono, you will see a self-extracting installer,
which you should run as before.

\end{enumerate}

Here is how to do a quick sanity check of your Mono setup:
\begin{enumerate}
\item {} 
Open the Start Menu and type ``mono'' in the text field at the bottom.
You should see a short list places ``mono'' appears.

\item {} 
Click on the choice that says ``Mono 2.10... Command prompt''.
If it comes up, you are all set.
Close the window, or save it for later use....
You can also find the program in the Start Menu manually,
finding the Mono folder, expanding it, and clicking on{]}
the Mono Command Prompt.

\item {} 
If the two preceding steps were successful, you can launch
MonoDevelop by double-clicking the icon in your Applications
folder. (You won't know what to do with it yet, but at least you can
verify that it launches correctly and then close the window.
Ctrl-Q is a shortcut.)

\end{enumerate}


\subsection{Linux}
\label{monotools:linux}
We only provide instructions for Debian-based Linux distributions such
as Ubuntu.
\begin{enumerate}
\item {} 
Using the command-line \code{apt-get} tool, you can install everything
that you need using \code{apt-get install monodevelop}. This should be
run as the \textbf{root} user (using the \code{sudo} command).

\item {} 
You can test the sanity of your setup by following the instructions
under OS X.

\end{enumerate}

MonoDevelop releases on Linux tend to lag behind the official stable
release.

This page,
\href{https://launchpad.net/~keks9n/+archive/monodevelop-latest}{https://launchpad.net/\textasciitilde{}keks9n/+archive/monodevelop-latest},

describes
how to update your MonoDevelop setup if it is not version 2.8 or later
as we'll need for this course.

We wish to stress that Linux is recommended for students who already
have a bit of programming experience under their belts. It can take a
significant amount of energy to get a Linux setup up and running and
to tweak it to your liking. While it has gotten ever so much easier
since the 1990s when it first appeared, we encourage you to set it up
perhaps a bit later in the semester or consider running it using
virtualization software (on Mac or Windows) such as VirtualBox or
VMware.


\section{Lab Exercise: Editing, Compiling, and Running}
\label{lab-edit-compile-run:lab-exercise-editing-compiling-and-running}\label{lab-edit-compile-run::doc}

\subsection{Summary}
\label{lab-edit-compile-run:summary}
This first lab is aimed at taking you through the end-to-end process of
writing and running a basic computer program. As with all things in
life, we will learn in this lab that becoming a programmer requires you
to learn a number of other things along the way.

In software development/engineering parlance, we typically describe a
scenario as a \emph{workflow}, which can be thought of as a series of steps
that are possibly repeated. The workflow of programming can loosely be
defined as follows:
\begin{enumerate}
\item {} 
Use a text editor to write your source code (human readable).

\item {} 
Compile your code using the Software Development Kit (SDK) into
object code.

\item {} 
Link your object code to create an executable. (There are other
kinds of results to produce, but we will start with the idea of an
executable program to keep things simple.)  The default is to nave
an executable program created with compilation, automatically.

\item {} 
Run your program. Even for the most seasoned developers, your
program may not work entirely right the first time, so you may end
up repeating these steps (debugging).

\end{enumerate}

As we will learn later in the course, development environments such as
Visual Studio (from Microsoft) and MonoDevelop (an open source
implementation similar to Visual Studio) basically shield you from the
details of understanding the workflow in detail. We think it is
important that you \emph{learn} this workflow from day one, because many types
of software development don't always have the easiest software
development tools.  You will be able to use fancy tools later.


\subsection{To be completed in the lab}
\label{lab-edit-compile-run:to-be-completed-in-the-lab}
The following is the code for a very well-known program, \emph{Hello,
World!}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{namespace} \PYG{n+nn}{Comp170}
\PYG{p}{\PYGZob{}}
   \PYG{k}{public} \PYG{k}{class} \PYG{n+nc}{Hello}
   \PYG{p}{\PYGZob{}}    
      \PYG{k}{public} \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hello World!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This program is deliberately simple, so you can type it into a text
editor (Emacs is recommended but your instructor may introduce you to
a different editor, subject to availability in the lab) quickly and become familiar with how
to create, edit, and save a program. Perform the following steps. (You
are free to deviate but may want to consider following the steps
religiously at least once to ensure you were successful.)
\begin{enumerate}
\item {} 
Open the text editor. This can usually be done from your
GUI's start menu.

\item {} 
Create a folder anywhere you like (e.g. in Documents) and name it
\code{hello}. (This can be done through the desktop shell
(e.g. Windows Explorer or Apple Finder.) As a general rule, we
recommend that you start any new programming project in its own
folder that is free of other folders/files. Clutter is a great
enemy of those who aspire to become good programmers.

\item {} 
When you start in Emacs, you are in what is known as \emph{scratch}
mode.  Typical of a sketchpad used by artists, this is where you
can start typing right away. You can now begin typing in the text
above. Keep in mind that the exact formatting is not important at
this stage; however, as we progress in this course, you'll \emph{want}
to pay attention to how your code is formatted. (With most text editors, it is
possible to reformat your code to make it \emph{beautiful}. More on
that later.)

\item {} 
Once you have entered the text, you will want to \emph{save} it, just
as if you were saving a file in your word processor. (In the Emacs
text editor, you use Control-x, Control-s. You will want to save
the file with the name \code{Hello.cs}. If you are using a graphical
text editor (like the case) then you will usually be able to save
from the File menu, much like you would do in a regular word
processor. Keep in mind, however, that you will eventually want to
learn the \emph{keyboard shortcuts} for your editor as much development
work in the real world happens from the command line and remote
terminal sessions (e.g. web and embedded systems development).

\item {} 
If all has gone well, you will now have a version of \emph{Hello,
World} in a file named \code{Hello.cs} in a folder named \code{hello}
(located in \code{Documents}).

\item {} 
Now we are going to learn how to compile this program. For this,
you will need to open a shell. On Linux and OS X, the shell is
opened by launching Terminal. On Windows, open a Mono Command
Prompt, as discussed above (or use one you left open).  Again to
find it:
\begin{itemize}
\item {} 
OS X: Applications -\textgreater{} Terminal (double click it)

\item {} 
Linux: Applications -\textgreater{} Terminal

\item {} 
Windows: Start Menu, search for Mono Command Line

\end{itemize}

\item {} 
Now you need to learn how to ``move around'' using the shell. The
command shell basically awaits user input and does whatever it is
told (and does nothing otherwise). You'll begin by using the ``cd''
command to change your working directory to where you saved
\code{Hello.cs}.  Note: Replace Dr. Thiruvathukals's login id gkt by
your login id.  Also note for Mac/Unix examples that his machine
is called macaroni.

If you did everything right, you can do this on Windows:

\begin{Verbatim}[commandchars=\\\{\}]
C:\PYGZbs{}Windows\PYGZbs{}System32\textgreater{} cd C:\PYGZbs{}users\PYGZbs{}gkt
C:\PYGZbs{}Users\PYGZbs{}gkt\textgreater{} cd Documents\PYGZbs{}hello
C:\PYGZbs{}Users\PYGZbs{}gkt\PYGZbs{}Documents\PYGZbs{}hello\textgreater{}
\end{Verbatim}

Mac/Linux:

\begin{Verbatim}[commandchars=\\\{\}]
\$ cd Documents/hello
\end{Verbatim}

\item {} 
If you are on OS X or Linux, you can list the directory using the
\code{ls} command. If the output you see here does not match, make
sure you are in the \code{hello} folder:

\begin{Verbatim}[commandchars=\\\{\}]
\$ ls

macaroni:hello gkt\$ ls
Hello.cs

\$ pwd
/Users/gkt/Documents/hello
\end{Verbatim}

\item {} 
If you're on Windows, can list the contents of the directory using
\code{dir}:

\begin{Verbatim}[commandchars=\\\{\}]
C:\PYGZbs{}Users\PYGZbs{}gkt\PYGZbs{}Documents\PYGZbs{}hello\textgreater{}dir
         Volume in drive C has no label.
         Volume Serial Number is 2C13-C918

         Directory of C:\PYGZbs{}Users\PYGZbs{}anh\PYGZbs{}Documents\PYGZbs{}hello

        01/16/2012  06:07 PM    \textless{}DIR\textgreater{}          .
        01/16/2012  06:07 PM    \textless{}DIR\textgreater{}          ..
        11/04/2011  08:20 PM               646 Hello.cs

        ...
\end{Verbatim}

\item {} 
If you are unable to see \code{Hello.cs} at this stage, you need to
go back and check all previous steps. It is entirely possible you
did not create the folder or save properly. If you think you
completed these steps, this is a good time to ask the instructor
or teaching assistant for help.

\item {} 
Assuming you are able to see \code{Hello.cs} in the \code{hello} folder,
we are now ready for \emph{the good stuff*\textasciitilde{}\textasciitilde{}the technical term we use
when we are about to learn something that we need to know how to
do *for life}. We're going to compile the \code{Hello.cs} program
into \code{Hello.exe} so we can run it. FYI, you should still be in
the Terminal/DOS window where we just listed the directory (this
works regardless of what OS you are using). Enter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{gmcs} \PYG{n}{Hello}\PYG{p}{.}\PYG{n}{cs}
\end{Verbatim}

\item {} 
If everything worked right, you will not see any output. If you
spot any error messages, it means that you probably made a typo
when copying/typing the sample code into the text editor. Go back
to step @EditHello and check that everything is typed
properly. (We will not be discussing all the possible errors you
an encounter at this stage, but you might find them helpful to
edit your program.) If your text editor is not still open, then
you need to re-open the file, which can be done easily by using
File \code{-\textgreater{}} Open and browsing your folder structure to find folder
\code{hello}, then \code{Hello.cs}.

\item {} 
Now for the great moment you have been awaiting: You can \emph{run}
\code{Hello.exe}.  Enter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mono} \PYG{n}{Hello}\PYG{p}{.}\PYG{n}{exe}
\end{Verbatim}

You should see the result:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Hello}\PYG{p}{,} \PYG{n}{World}\PYG{p}{!}
\end{Verbatim}

\end{enumerate}

At this point, we have accomplished the major objective for Lab 0: to
enter, compile, and run a C\# program. In the next lab, we will work on
some revisions to \code{Hello.cs} to personalize it a bit.

As this point, you should grab the instructor or teaching assistant so
they can perform a quick inspection of your work and check it off. Per
the syllabus, labs are not graded but do need to be completed to receive
credit. If you are unable to make class on a lab day, please make sure
that you complete the work and demonstrate it by the beginning of the
next lab.


\subsection{For further reinforcement}
\label{lab-edit-compile-run:for-further-reinforcement}\begin{enumerate}
\item {} 
Download and install the Emacs and Mono Software Development Kit on
your home computer or laptop.

\item {} 
Make sure you can do everything that you just completed in the lab.

\item {} 
See whether you can get a head start on Lab 1.

\end{enumerate}


\subsection{Some Useful Resources for Learning Emacs}
\label{lab-edit-compile-run:some-useful-resources-for-learning-emacs}\begin{enumerate}
\item {} 
The GNU Emacs Tutorial, \href{http://www.gnu.org/software/emacs/tour/}{http://www.gnu.org/software/emacs/tour/}

\item {} 
University of Chicago Libraries Emacs Tutorial,
\href{http://www2.lib.uchicago.edu/keith/tcl-course/emacs-tutorial.html}{http://www2.lib.uchicago.edu/keith/tcl-course/emacs-tutorial.html}

\end{enumerate}


\subsection{Other Useful Text Editors}
\label{lab-edit-compile-run:other-useful-text-editors}
\#. Gedit, \href{http://gedit.org}{http://gedit.org}, is a very nice editor that comes with most
Linux/Gnome distributions. Although it allegedely runs on Windows and OS X, we
have not had a chance to test it and cannot recommend it at this time.
\begin{enumerate}
\item {} 
Vim,  \href{http://www.vim.org/docs.php}{http://www.vim.org/docs.php}, is another popular editor based
on the famous \textbf{vi} text editor that goes back a number of
decades. There are graphical versions for Linux, Mac, and Windows.

\end{enumerate}

Unfortuntely, these are not available in the Windows labs yet (unlike
Emacs); however, students working in the Linux laboratory have access
to these editors and may wish to learn them.


\subsection{What's next in Lab 1?}
\label{lab-edit-compile-run:what-s-next-in-lab-1}
We'll continue learning more about C\#. The next lab will give you
exposure to the C\# interactive mode (in Mono, the \code{csharp} command),
where we will learn to work with arithmetic and basic primitive types.
The \code{csharp} command allows you to use C\# as a sort of ``toy
calculator'' language. It also allows you to test capabilities of the C\#
\emph{programming library}. For example, we will learn some other things you
can do with the \code{Console} interfaces, including how to prompt a user
for input.


\section{Comments on Miles Simple Data}
\label{milessimpledata:comments-on-miles-simple-data}\label{milessimpledata::doc}
Miles Chapter 2 on Simple Data Processing is also well written.  As you \emph{read it},
note the specific comments below.   The chapter does not mention the Mono tool,
csharp, which makes it very easy to test simple data operations.
\begin{description}
\item[{Page 27}] \leavevmode
The table is for reference, context, and completeness:
You do NOT need to memorize all the types, particularly now!
Mostly used are int and char, and possibly long for really big numbers.

\item[{Page 28}] \leavevmode
We will mostly stick to double for convenience.
Using smaller versions is only important if you have enormous collections of data.
You do not need to use the E notation – though you may see it.

\item[{Page 29}] \leavevmode
This is another table for reference/completeness.
The only escape code we are likely to use are \textbackslash{}n, \textbackslash{}\textbackslash{}, \textbackslash{}''.

\item[{Page 30}] \leavevmode
Unicode is nice if you want different languages and special symbols, but we will not use it.

\item[{Page 33}] \leavevmode
The precedence table is very misleading:
It does not distinguish operands with the SAME precedence:
Operators * and /, have the same precedence.
The binary operations + and - have the same precedence.

This is the same precedence as in normal math.  See the related section added below
about another useful operator related to division, the remainder operator, \%.
It has the same precedence as * and /.

\item[{Page 34-35:}] \leavevmode
The idea of casting numbers is important,
that the same abstract number may have different representations,
and some are more or less accurate.
In practice the main cast for us will be int to double.
Make sure you realize that casting double to int is NOT the same as rounding; instead
it removes the fractional part whether high, .999, low, 0.1, or in the middle, .5.

\end{description}

\index{division!remainder}\index{remainder!division}

\section{Division and Remainders}
\label{remainders:index-0}\label{remainders::doc}\label{remainders:division-and-remainders}\label{remainders:id1}
Try in the csharp shell.  Be sure to include the decimal points:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{5.0}\PYG{p}{/}\PYG{l+m}{2.0}\PYG{p}{;}
\PYG{l+m}{1}\PYG{l+m}{4.0}\PYG{p}{/}\PYG{l+m}{4.0}\PYG{p}{;}
\end{Verbatim}

On the other hand, try in csharp:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{4}\PYG{p}{/}\PYG{l+m}{4}\PYG{p}{;}
\end{Verbatim}

you get something that looks strange:  Just and addition, subtraction, and multiplication
of \code{int}s produces and \code{int}, so, too with division.

In C\#, the result of the / operator depends on the
type of the operands, not on the mathematical value of the operands.

If you think about it, you learned several ways to do division.
Eventually you learned how to do division resulting in a decimal.
In the earliest grades you would say
\begin{quote}

``14 divided by 4 is 3 with a remainder of 2''.
\end{quote}

Note the the quotient is an integer 3, that matches the C\# evaluation of 14/4,
so having a way to generate an integer quotient is not actually too strange.
The problem here is
that the answer from grade school is in two parts, the integer quotient 3 and the
remainder 2.

C\# has separate operation to generate the remainder part.  There is no standard
single operator character operator in regular math, so C\# grabs an unused symbol
(the same ias in many other computer languages): \% is the remainder operator.

Try in the csharp shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{4}\PYG{p}{\PYGZpc{}}\PYG{l+m}{4}\PYG{p}{;}
\end{Verbatim}

You see you do get the remainder from our grade school division.

Now predict and then try each in the csharp shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{2}\PYG{l+m}{3}\PYG{p}{/}\PYG{l+m}{5}\PYG{p}{;}
\PYG{l+m}{2}\PYG{l+m}{3}\PYG{p}{\PYGZpc{}}\PYG{l+m}{5}\PYG{p}{;}
\PYG{l+m}{2}\PYG{l+m}{0}\PYG{p}{\PYGZpc{}}\PYG{l+m}{5}\PYG{p}{;}
\PYG{l+m}{6}\PYG{p}{/}\PYG{l+m}{8}\PYG{p}{;}
\PYG{l+m}{6}\PYG{p}{\PYGZpc{}}\PYG{l+m}{8}\PYG{p}{;}
\PYG{l+m}{6.0}\PYG{p}{/}\PYG{l+m}{8}\PYG{p}{;}
\end{Verbatim}

The / operator can be confusing, depending on the type, not the mathematical value.
Note that if at least one operand is double, the result was be.

Finding remainders will prove more useful than you might think in
the future!


\subsection{Exercise for Quotients}
\label{remainders:quotientproblem}\label{remainders:exercise-for-quotients}
Write a program, \code{quotient.cs}, that
prompts the user for two integers, and then prints them out in a
sentence with an integer division problem like

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{quotient} \PYG{n}{of} \PYG{l+m}{1}\PYG{l+m}{4} \PYG{n}{and} \PYG{l+m}{3} \PYG{k}{is} \PYG{l+m}{4} \PYG{n}{with} \PYG{n}{a} \PYG{n}{remainder} \PYG{n}{of} \PYG{l+m}{2}
\end{Verbatim}


\section{Substitutions in Console.WriteLine}
\label{writeline-substitution:substitutions-in-console-writeline}\label{writeline-substitution::doc}

\subsection{Output With \texttt{+}}
\label{writeline-substitution:output-with}
An elaboration of a ``Hello, World'' program, could greet the user,
after obtaining the user's name.  If the user enters thje name
Kim, the program could print
\begin{quote}

Hello, Kim!
\end{quote}

This is a very simple
input-process-output program (in fact with almost no ``process'').
Think how would you code it?

You need to obtain a name, remember it and use it in your output.
A solution is in the next section.

\index{WriteLine!\{\} for format}\index{\{\} for format!WriteLine}

\subsection{String Format Operation}
\label{writeline-substitution:index-0}\label{writeline-substitution:string-format-operation}\label{writeline-substitution:format-strings}
A common convention is fill-in-the blanks. For instance,
\begin{quote}

Hello, \_\_\_\_\_!
\end{quote}

and you can fill in the name of the person greeted, and combine
given text with a chosen insertion. C\# has a similar
construction, better called fill-in-the-braces,
that can be used with \code{Console.WriteLine}.

Instead of inserting user input with the \code{+} operation as in
\code{HelloYou1.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{HelloYou1}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"What is your name?"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{name} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hello, "} \PYG{p}{+} \PYG{n}{name} \PYG{p}{+} \PYG{l+s}{"!"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

look at a variation, \code{HelloYou2.cs}, shown below.
Both programs
look exactly the same to the user:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{HelloYou}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"What is your name?"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{name} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hello, \PYGZob{}0\PYGZcb{}!"}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\code{Console.WriteLine} actually can take parameters \emph{after} an initial string,
but only when  the string is in the form of a \emph{format string},
with expression(s) in braces where substitutions are to be made,
(like in fill-in-the-blanks).

The remaining parameters, after the initial string,
give the values to be substituted.  To
know \emph{which} further parameter to substitute, the parameters after the
initial string are implicitly numbered,
\emph{starting from 0}.
Starting with 0 is consistent with other numbering sequences in C\#.
So here, where there is just one value to substitute, it gets the index 0,
and where it is substituted, the braces get 0 inside, to indicate
that parameter 0 is to be substituted.

Everything in the initial string that is \emph{outside} the braces is just
repeated verbatim.  In particular, if the only parameter is a string
with no braces, it is printed completely
verbatim (as we have used \code{Console.WriteLine} before).

A more elaborate silly examples that you could test in csharp would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string} \PYG{n}{first} \PYG{p}{=} \PYG{l+s}{"Peter"}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{last} \PYG{p}{=} \PYG{l+s}{"Piper"}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{what} \PYG{p}{=} \PYG{l+s}{"pick"}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{}, \PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{}, \PYGZob{}2\PYGZcb{}."}\PYG{p}{,} \PYG{n}{first}\PYG{p}{,} \PYG{n}{last}\PYG{p}{,} \PYG{n}{what}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

It would print:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Peter} \PYG{n}{Piper}\PYG{p}{,} \PYG{n}{Peter} \PYG{n}{Piper}\PYG{p}{,} \PYG{n}{pick}\PYG{p}{.}
\end{Verbatim}

where parameter 0 is \code{first} (value \code{"Peter"}),
parameter 1 is \code{last} ( value \code{"Piper"}), and
parameter 2 is \code{what} (value \code{"pick"}).

Make sure you see why the given output is exactly what is printed.

Or try in csharp:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{7}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{y} \PYG{p}{=} \PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} plus \PYGZob{}1\PYGZcb{} = \PYGZob{}2\PYGZcb{}; \PYGZob{}0\PYGZcb{} times \PYGZob{}1\PYGZcb{} = \PYGZob{}3\PYGZcb{}."}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{+}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{*}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and see it print:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{7} \PYG{n}{plus} \PYG{l+m}{5} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{2}\PYG{p}{;} \PYG{l+m}{7} \PYG{n}{times} \PYG{l+m}{5} \PYG{p}{=} \PYG{l+m}{3}\PYG{l+m}{5.}
\end{Verbatim}

Note the following features:
\begin{itemize}
\item {} 
Parameters can be any expression,
and the expressions get evaluated before printing.

\item {} 
Parameters to be substituted can be of any type.

\item {} 
The parameters are automatically converted to a string form, just as in the
use of the string \code{+} operation.

\end{itemize}

In fact the simple use of format strings
shown so far can be completed replaced by long expressions with \code{+},
if that is your taste.  Miles later (on page 50) discusses fancier formatting,
that \emph{cannot} be duplicated with a simple string \code{+} operation.
We will just use the simple numbered substitutions for now,
to get used to the idea of substitution.

A technical point: Since braces have special meaning in a format
string, there must be a special rule if you want braces to actually
be included in the final \emph{formatted} string. The rule is to double
the braces: \code{'\{\{'} and \code{'\}\}'}. The fragment

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{,} \PYG{n}{b} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"The set is \PYGZob{}\PYGZob{}\PYGZob{}0\PYGZcb{}, \PYGZob{}1\PYGZcb{}\PYGZcb{}\PYGZcb{}."}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

produces

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{k}{set} \PYG{k}{is} \PYG{p}{\PYGZob{}}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{.}
\end{Verbatim}
\phantomsection\label{learning-to-problem-solve:learn-solve}
\index{problem solving!strategy}

\section{Learning to Solve Problems}
\label{learning-to-problem-solve:index-0}\label{learning-to-problem-solve::doc}\label{learning-to-problem-solve:learning-to-solve-problems}
This section might have been placed earlier,
but by placing it here,
you should realize that you will have a \emph{lot} of data to deal with.

The manner in which you deal with all the data and ideas is very important for effective learning.
It might be rather different than what you needed if you were in a situation
where \emph{rote} recall is the main important thing.

Different learning styles mean different things are useful to different people.
Consider what is mentioned here and try out some approaches.

The idea of this course is not to regurgitate the notes, but to learn to solve problems
(generally involving producing a computer program).
In this highly connected and wired world
you have access to all sorts of data.  The data is not an end in itself, the question is
\emph{doing} the right things with the tools out there.

In this course there is a lot of data tied into syntax and library function names and ....
It can seem overwhelming.  It need not be. Take a breath.

First basic language syntax:  When learning any new language, there is a lot to take in.
We introduce C\# in chunks.  For a while there will always be the new current topic coming.
You do NOT need to memorize \emph{everything} immediately!
\begin{itemize}
\item {} 
Some things that you use rarely, you may never memorize, like,
``What is the exact maximum magnitude of a \code{double}?''  At \emph{some} point that might be useful.
Can you find it?  It happens to be in a table in Miles.  It is also in online .Net documentation
that you can Google or bookmark.

\item {} 
Some things you will use all the time, but of course they start off as new and maybe strange.
Knowing where to go to check is still useful but not sufficient. For much-used material
that you do not find yourself obsorbing immediately,
consider writing down a summary of the current topic.
Both thinking of a summary and writing help reinforce things and get you to remember faster.
Also, if you have the current things of interest summarized in one place, they are easy to look
up!

\item {} 
If you need some syntax to solve a simple early problem,
first try to remember the syntax, then check.  With frequently
used material with this sort of repetition,
most everyone will remember most everything shortly.  If there are a few things
that just do not stick, keep them in your list.  Then go on to new material.  The list of
what you need to check on will keep changing as you get more experience and get to more topics.
If you keep some of the old lists, you will be amazed how much stuff that you sweated over,
is later ho-hum or automatic.

\item {} 
Earliest exercises
should have the general steps needed pretty apparent, and you can just concentrate on
translating simple ideas into C\# syntax
(likely concentrating on the material most recently introduced).
In this case the focus is mostly on syntax.

\end{itemize}

Memorizing syntax is not going to directly get you to solve real problems.  In any domain:
programming, construction, organizing political action, ..., you need to analyse the problem
and figure out a sequence of steps, knowing what powers and resources you have.

For example with political action:
if you know demonstrations are possible in front of City Hall, you can make a high-level
plan to have one, but then you have to attend to details:  Do you need city permission?
Who do you call? ... You do not have to have all that in your head when coming up with the
idea of the demonstration, but you better know how to find the information allowing you
to follow through to make it happen.

With programming, syntax details are like the details above: not the first thing to think of,
and maybe not things that you have memorized.  What \emph{is} important to break down a problem
and plan a solution, is to know the basic capacities you have in programming.  As you get
into larger projects and have more experience, ``basic capacities'' will be bigger and bigger ideas.
For now, as beginners, it is important to know:
\begin{itemize}
\item {} 
You can get information from a user and return information via keyboard and screen.

\item {} 
You can remember and recall and use information using variables.

\item {} 
You can deal directly with various kinds of data: numbers and Strings at this point.

\item {} 
There are basic operations you can do with the data (arithmetic, contatenating string,
converting between data types).

\item {} 
At a slightly higher level, you might already have the idea of basic recurring patterns,
like solving a straightforward problem with \textbf{input-processing-output}.

\item {} 
You will shortly see that you have more tools:  decision, repetition, more built-in
ways to deal with data (like more string operations shortly), creating your own data types....

\end{itemize}

At slightly more detailed level, \emph{after} thinking of overall plans:
\begin{itemize}
\item {} 
There are multiple kinds of number types.  What is appropriate for your use?

\item {} 
There are various ways of formatting and presenting data to output. What shall you use?

\end{itemize}

\emph{Finally}, you actually need to translate specific instructions into C\# (or whatever language).
Of course if you remember the syntax, then this level of step is pretty automatic.
Even if you do \emph{not} remember, you have something very specific to look up!  If you are
keeping track of your sources of detailed information, this is hopefully only one further
step.

Contrast this last-step translation with the earlier creative organizational process:
If you do not have \emph{in your head} an idea of the basic tools available,
how are you going to plan?
How are you going to even know how to start looking something up?

So far basic ideas for planning a solution has been discussed, and you can see that you do not
need to think of everything at once or have everything equally prominent in your brain.

Also, when you are coding, you do not need to to have all the details of syntax in your head,
even for the \emph{one} instruction that you are dealing with at the moment.  You want to have
the main idea, and you want to get it written down, but once it is written down, you can make
multiple passes, examining and modifying what you have.  For example, Dr. Harrington does a lot of
Python programming, where semicolons are not needed.  He can get the main ideas down
in C\# without the required
semicolons.  He \emph{could} wait for the compiler to stop him on every one that is missed,
and maybe have the compiler misinterpret further parts, and give bogus error messages.
\emph{More effective} is having
a list of things to concentrate on in later rounds of manual checking.
For example, checking for semicolons: Scan the statements;
look at the ends; add semicolons where missing.  You can go through a large program very
quickly and efficiently doing this and have one less thing to obsess about when first writing.

This list of things-to-check-separately should come from experience.
Keep track of the errors you make.  Some people even keep an error log.
What errors keep occuring?
Make entries in things-to-check-separately,
so you will make scans checking for the specific thinsg you frequently slip up on.

This things-to-check-separately list, too, will evolve.  Revise it occasionally.
If Dr. Harrington does enough
concentrated C\#, \emph{maybe} he will find that entering semicolons becomes automatic,
and he can take the separate round of semicolon checking off his list.

What to do \emph{after} you finish an exercise is important, too.  The natural thing psychologically,
particularly if you had a struggle, is to think, ``Whew, outa here!!!!''

On something that came automatically or flowed smoothly, that is not a big deal -
you will probably get it just as fast the next time. If you had a hard time and only eventually
got to success, you may be doing yourself a disservice with ``Whew, outa here!!!''

We have already mentioned how not everything is equally important, and some things are more
important to keep in your head than others.  The same applies to all the steps in solving
a possibly long problem.  Some parts were easy; some were hard; there may have been many steps.
If all of that goes into your brain in one continuous stream of stuff that you
remember at the same level, then you are going to leave an awful lot as just unimportant
and basically useless (so why do the problem anyway?), \emph{or} have a
brain \emph{very} stuffed with things you want to recall.

What is important?  The most obvious thing you will need at a higher level of recall is what
\emph{just messed you up}, what you missed until doing this problem:  After finishing the
actual problem, \emph{actively} follow up and ask yourself:
\begin{itemize}
\item {} 
What did I get in the end that I was misssing initially? What was the connection I made?

\item {} 
Does this example fit in to some larger idea/abstraction/generalization in a way that
I did not see before?

\item {} 
How am I going to look at this so I can make a similar connection
in a similar (or maybe only partly similar) problem?

\item {} 
Is there a kernal here that I can think of as a new tool in my bag of tricks?

\end{itemize}

Your answers are the most important things to take away.
The extra consideration puts them more in
the ``priority'' part of your brain, so you can really learn from your effort.  When you need
the important ideas
next, you do not need to play through all the details of
the stuff you did to solve the exact earlier problem.

\index{labs!division sentences}

\section{Lab: Division Sentences}
\label{lab-division-sentences:index-0}\label{lab-division-sentences::doc}\label{lab-division-sentences:lab-division-sentences}

\subsection{Overview}
\label{lab-division-sentences:overview}
In this lab, we're going to begin to look at what makes computers \emph{do
their thing} so to speak.

It is rather insightful to look at how Wikipedia summarizes the
computer:
\begin{quote}

A computer is a programmable machine designed to sequentially and
automatically carry out a sequence of arithmetic or logical
operations. The particular sequence of operations can be changed
readily, allowing the computer to solve more than one kind of
problem.
\end{quote}

In other words, a computer is a calculator--and much
more. Furthermore, the definition of a computer goes on to include
access to storage and peripherals, such as consoles (graphical displays),
printers, and the network. We already got a glimpse of this access
when we explored \code{Console.WriteLine} in the first lab exercise.

So in this lab, we're going to explore the use of C\# as a
calculator. We're going to begin by looking at the \textbf{csharp} command
as opposed to the compiler (\textbf{gmcs} that we used in the first
lab). Then we will take what we've learned in this session and use it
to write a full program.


\subsection{Requirements}
\label{lab-division-sentences:requirements}
We want to develop a program that can do the following:
\begin{itemize}
\item {} 
Prompt the user for input of two integers, which we will call
\emph{numerator} and \emph{denominator}. For clarity, we are only looking at
integers, because this assignment is about rational numbers. A
rational number can always be expressed as a quotient of two integers.

\item {} 
Calculate the floating point division result (e.g. 10/4 = 2.5).

\item {} 
Calculate the quotient and the remainder (e.g. 10/4 = 2 with a
remainder of 2 = 2 2/4).

\item {} 
If the remainder is \textgreater{} 0, print the remainder / denominator as a
fraction. Otherwise, don't print anything.

\end{itemize}

So we will do some basic calculations. We will also make use for the
first time of an \emph{if} statement, which will allow us to determine
whether a fraction is printed or not.

As an example of how this program will ultimately work:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Please} \PYG{n}{enter} \PYG{n}{the} \PYG{n}{numerator}\PYG{p}{?} \PYG{l+m}{1}\PYG{l+m}{4}
\PYG{n}{Please} \PYG{n}{enter} \PYG{n}{the} \PYG{n}{denominator}\PYG{p}{?} \PYG{l+m}{4}
\PYG{n}{Floating} \PYG{n}{point} \PYG{n}{division} \PYG{n}{result} \PYG{p}{=} \PYG{l+m}{3.5}
\PYG{n}{Integer} \PYG{n}{division} \PYG{n}{result} \PYG{p}{=} \PYG{l+m}{3} \PYG{n}{remainder} \PYG{l+m}{2}
\PYG{n}{Result} \PYG{k}{as} \PYG{n}{a} \PYG{n}{fraction} \PYG{p}{=} \PYG{l+m}{3} \PYG{l+m}{2}\PYG{p}{/}\PYG{l+m}{4}
\end{Verbatim}

We will later learn how to turn the 3 2/4 into a reduced
fraction. This will be achieved using a famous method known as the
\emph{greatest common divisor} algorithm, which has a very simple
formulation that is credited to Euclid, of of the great early
mathematicians (among other things).


\subsection{csharp}
\label{lab-division-sentences:csharp}
So let's get this party started by firing up the \textbf{csharp}
command. Open a terminal (Linux or OS X) or command window for the
Mono tools, which we know how to use from previous work:

\begin{Verbatim}[commandchars=\\\{\}]
\$ csharp
Mono C\# Shell, type "help;" for help

Enter statements below.
csharp\textgreater{}
\end{Verbatim}

The \code{csharp\textgreater{}} prompt tells you that the C\# interpreter has started
and is awaiting input. This allows you to create C\# variables and
execute C\# statements without having to write a full program.

You can also use features of the C\# programming
library (e.g. the \code{Console.WriteLine} we learned about in the
previous lab):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Please enter the numerator?"}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Please} \PYG{n}{enter} \PYG{n}{the} \PYG{n}{numerator}\PYG{p}{?}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{input} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{2}\PYG{l+m}{5}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{numerator} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{input}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{numerator}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{2}\PYG{l+m}{5}
\end{Verbatim}

Before we continue with this session, please note that it is ok to
make mistakes. The C\# interpreter tends to be forgiving, although
there are some cases where you might find yourself a bit
confused. Here's an example of something that could happen to you in
the course of typing a statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{denominator} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}
\PYG{p}{\textgreater{}}
\end{Verbatim}

In this example, I accidentally hit the return/enter key after
entering the left parenthesis. For \code{int.Parse(} to work, it needs
more input to bring the statement to completion. For example, it needs
to know \emph{what to parse} and must be a complete C\# statement. The
closing parenthesis and statement terminator (semicolon) need to be
typed for this to happen.

So we can either continue entering the input:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{denominator} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}
\PYG{p}{\textgreater{}} \PYG{n}{input}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Or we can type semicolon (;) followed by return/enter to end the input
and try again:

\begin{Verbatim}[commandchars=\\\{\}]
csharp\textgreater{} int denominator = int.Parse(
\textgreater{} ;
\PYGZob{}interactive\PYGZcb{}(2,0): error CS1525: Unexpected symbol {}`;'
\end{Verbatim}

This will force the statement to be processed by the C\# interpreter
and give an error. You can then \emph{try again} if you like!

A particularly useful feature of the C\# interpreter is the
\code{ShowVars()} function. (Yes, we know you haven't fully learned
functions yet, but we're introducing some things by doing them and
will be explaining more formally later.) \code{ShowVars()} prints the
list of variables and their values that have been defined in a given
session:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{ShowVars}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{denominator} \PYG{p}{=} \PYG{l+m}{4}
\PYG{k+kt}{int} \PYG{n}{numerator} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{4}
\PYG{k+kt}{string} \PYG{n}{input} \PYG{p}{=} \PYG{l+s}{"14"}
\PYG{k+kt}{string} \PYG{n}{input2} \PYG{p}{=} \PYG{l+s}{"4"}
\end{Verbatim}

This just happens to be the list of variables/values that are defined
in my session. Yours may vary depending on what variables you typed,
etc.

Now let's use the C\# operators to get the quotient and the remainder:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{quotient} \PYG{p}{=} \PYG{n}{numerator} \PYG{p}{/} \PYG{n}{denominator}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{quotient}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{remainder} \PYG{p}{=} \PYG{n}{numerator} \PYG{p}{\PYGZpc{}} \PYG{n}{denominator}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{remainder}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{2}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} / \PYGZob{}1\PYGZcb{} = \PYGZob{}2\PYGZcb{} remainder \PYGZob{}3\PYGZcb{}"}\PYG{p}{,} \PYG{n}{numerator}\PYG{p}{,} \PYG{n}{denominator}\PYG{p}{,} \PYG{n}{quotient}\PYG{p}{,} \PYG{n}{remainder}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{1}\PYG{l+m}{4} \PYG{p}{/} \PYG{l+m}{4} \PYG{p}{=} \PYG{l+m}{3} \PYG{n}{remainder} \PYG{l+m}{2}
\end{Verbatim}

Because we are working with integer data, we need the ability to get
the result of the division and the remainder \emph{as integers}. As shown,
14 / 4 results in 3. That's because the remainder is not included (nor
can it be) unless we use another data type (float) that can hold the
full result of a division operation.

C\# gives you the ability to get the remainder using a separate
operation known as the \emph{modulus} operator. This operator is what we
sometimes call a \emph{convenience} operator, because we all learned in
basic mathematics that the remainder = numerator - quotient *
denominator (here the remainder is 14 - 3 * 4 = 2).

In the above, we are also introducing the ability to take the results
of a calculation and \emph{format} them using \code{Console.WriteLine}. Here
\{0\}, \{1\}, \{2\}, and \{3\} refer to each of the variables that follow the
text that we wish to print. Each of these variables will be
substituted into the string to produce the beautifully formatted
output that is shown:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{4} \PYG{p}{/} \PYG{l+m}{4} \PYG{p}{=} \PYG{l+m}{3} \PYG{n}{remainder} \PYG{l+m}{2}
\end{Verbatim}

You may find this example to be helpful to print the output according
to the requirements:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{4} \PYG{p}{/} \PYG{l+m}{4} \PYG{p}{=} \PYG{l+m}{3} \PYG{l+m}{2}\PYG{p}{/}\PYG{l+m}{4}
\end{Verbatim}

Now let's take a look at how we can get the results as a floating
point result. To do this, we must declare a couple of float (C\#'s
basic real number type) variables to hold each of the numerator and
denominator integers. Then we will declare a variable to capture the
result of the floating point division operation. Because division is
meaningful for all numeric data types, it is exactly the same
operator. C\# knows that the operator is being applied to floating
point data in this case, because we declared floating point
variables. (We will show how you can avoid declaring some of these
variables but are erring on the side of clarity.) We named each of the
floating-point variables with the number 2 in the name as C\# permits
variable names that have numbers and underscores after the first
character (which must be a \emph{letter} or an \emph{underscore}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{float} \PYG{n}{numerator2} \PYG{p}{=} \PYG{n}{numerator}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{float} \PYG{n}{denominator2} \PYG{p}{=} \PYG{n}{denominator}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{float} \PYG{n}{quotient2} \PYG{p}{=} \PYG{n}{numerator2}\PYG{p}{/}\PYG{n}{denominator2}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{quotient2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3.5}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} / \PYGZob{}1\PYGZcb{} = \PYGZob{}2\PYGZcb{} remainder \PYGZob{}3\PYGZcb{}"}\PYG{p}{,} \PYG{n}{numerator}\PYG{p}{,} \PYG{n}{denominator}\PYG{p}{,} \PYG{n}{quotient}\PYG{p}{,} \PYG{n}{remainder}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{1}\PYG{l+m}{4} \PYG{p}{/} \PYG{l+m}{4} \PYG{p}{=} \PYG{l+m}{3} \PYG{n}{remainder} \PYG{l+m}{2}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} / \PYGZob{}1\PYGZcb{} = \PYGZob{}2\PYGZcb{} exactly"}\PYG{p}{,} \PYG{n}{numerator2}\PYG{p}{,} \PYG{n}{denominator2}\PYG{p}{,} \PYG{n}{quotient2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{1}\PYG{l+m}{4} \PYG{p}{/} \PYG{l+m}{4} \PYG{p}{=} \PYG{l+m}{3.5} \PYG{n}{exactly}
\end{Verbatim}

So effectively we have shown everything you need to understand to
complete this lab. Your job in the remaining time is to see whether
you can use a text editor to create a program, which you can name
anything you like. We suggest calling it \code{DoTheMath.cs}. To help you
get started, we provided this simple \emph{template}. You'll probably find
it convenient to cut and paste code that you've already ``tried out'' (in
the C\# interpreter) into your text editor:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{namespace} \PYG{n+nn}{Comp170} \PYG{p}{\PYGZob{}}
   \PYG{k}{class} \PYG{n+nc}{DoTheMath} \PYG{p}{\PYGZob{}}
      \PYG{k}{public} \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
          \PYG{c+c1}{// Prompt the user for the numerator using}
          \PYG{c+c1}{// Console.WriteLine().}

          \PYG{c+c1}{// Convert this text into int numerator using}
          \PYG{c+c1}{// int.Parse().}

          \PYG{c+c1}{// Do the same for the denominator.}

          \PYG{c+c1}{// Calculate quotient and remainder (as integers)}
          \PYG{c+c1}{// Use Console.WriteLine() to make the results pretty as}
          \PYG{c+c1}{// above.}

          \PYG{c+c1}{// Do the same but using floating point division and not}
          \PYG{c+c1}{// doing the remainder calculation.}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Todo}

Add the bit about using the if statement. George to work on this
later.
\end{notice}


\subsection{Proper Indentation and Emacs java-mode}
\label{lab-division-sentences:proper-indentation-and-emacs-java-mode}
With this exercise, we are now entering a phase where we must start
paying a bit more attention to the basic \emph{appearance} of our code. As
programs become larger, they also can become harder to maintain (let
alone understand) if they are not formatted according to some basic
style guidelines.

As you'll come to learn in programming, different communities have
different conventions. The folks who make another open source C\# tool,
known as SharpDevelop (not used in this class but an awesome project)
have their own style guide that is particularly well written. See
\href{http://www.icsharpcode.net/technotes/sharpdevelopcodingstyle03.pdf}{http://www.icsharpcode.net/technotes/sharpdevelopcodingstyle03.pdf}.

In any event, luckily for us, we have access to editors like Emacs and
Gedit (in the Linux lab anyway) that support automatic source-code
indenting. In Emacs, you can enable this support by using
\emph{java-mode}. At the time of writing, there is actually a \emph{csharp-mode}
but it is not yet a part of the standard Emacs distribution. For the
most part, you can get by using \emph{java-mode}, given that C\# is very
similar to Java in terms of its overall syntax. It doesn't understand
keywords like \code{namespace} but otherwise seems to work in our
testing.

When in Emacs, you can enable Java mode in your buffer for
\code{DoTheMath.cs} by typing Escape-x. The minibuffer (the space you see
at the bottom of the screen where an \code{M-x} or similar prompt is
shown) will wait for you to type the name of a command. Enter
\emph{java-mode} and you will be able to take advantage of the magical
support in Emacs for automatic formatting of your source code. Your
instructor will show you how to make effective use of it.

If you are feeling a bit adventurous, you can download \emph{csharp-mode}
from the Emacs Wiki at
\href{http://www.emacswiki.org/emacs/CSharpMode}{http://www.emacswiki.org/emacs/CSharpMode}. All you need to do is save
the Emacs Lisp file (a file with the .el suffix) anywhere in your home
folder. Then you can use Emacs to load this file (Esc-x, then type
\emph{load-file}). You'll need to browse to the folder where you saved the
\emph{csharp-mode} code to complete the process. Then you ca type
\emph{csharp-mode} instead of \emph{java-mode}.

As this is a bit of an advanced topic, this explanation will have to
suffice for now. We're hopeful that future versions of Emacs will
include \emph{csharp-mode} by default.


\chapter{Defining Functions of your Own}
\label{functions:defining-functions-of-your-own}\label{functions::doc}\label{functions:defining-own-functions}
\index{syntax template!typography}\index{typography!syntax template}

\section{Syntax Template Typography}
\label{typography:syntax-template-typography}\label{typography:index-0}\label{typography::doc}\label{typography:id1}
When new C\# syntax is introduced, the usual approach will be to
give both specific examples and general templates. In general
templates for C\# syntax the typeface indicates the the category
of each part:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
Typeface
} & \textbf{
Meaning
}\\\hline

\code{Typewriter font}
 & 
Text to be written \emph{verbatim}
\\\hline

\emph{Emphasized}
 & 
A place where you can use an arbitrary
expression.
\\\hline

\textbf{Bold}
 & 
A place where you can use an arbitrary
identifier.
\\\hline

Normal text
 & 
A description of what goes in that position,
without giving explicit syntax
\\\hline
\end{tabulary}


An attempt is made with the parts that are not verbatim to be
descriptive of the use expected.

We will use these conventions shortly in the discussion of function
syntax, and will continue to use the conventions throughout the
notes.

\index{function!definition}\index{definition!function}

\section{A First Function Definition}
\label{firstfunc:index-0}\label{firstfunc::doc}\label{firstfunc:a-first-function}\label{firstfunc:a-first-function-definition}
If you know it is the birthday of a friend, Emily, you might tell
those gathered with you to sing ``Happy Birthday to Emily''.

We can make C\# display the song. \emph{Read}, and run if you like,
the example program \code{birthday1.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday1}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Emily."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Here the song is just a part of the \code{Main} method that is in
every program.

Note that we are using a function already provided to us,
\code{Console.WriteLine}.  We can use it over and over, wherever we like.
We can alter its behavior by including a different parameter.
Now we look further at writing and using your own functions.

If we
want this song to be just part of a larger program, and be able to refer
to it repeatedly and easily, we might like
to package it separately.
You would probably not repeat the whole song to let others know
what to sing. You would give a request to sing via a descriptive
name like ``Happy Birthday to Emily''.

In C\# we can also give a name like \code{happyBirthdayEmily}, and
associate the name with whole song by using a new
\emph{function definition}, also called a \emph{method}. We will see many variations
on method definitions.  Later we will see definitions that are
attached to a particular object.
For now the simpler cases do not involve creating a type of object,
but there is an extra word needed to distinguish a function definition
\emph{not} attached to  on object, \code{static}.
We will also shortly look at functions more like
the functions from math class, that produce or \emph{return} a value.  In
this simple case we will not deal with returning a value.
This also requires a special word in the heading:  \code{void}.  A \code{void}
function will just be a shorthand name for something to do, a procedure
to follow, in this case
printing out the Happy Birthday song for Emily.  (Note that
the \code{Main} method for a program is also \code{static void}.
This \emph{does} your whole program and is not attached to an object.)

\emph{Read} for now:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday2}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Emily."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}   
      \PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hip hip hooray!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

There are several parts of the syntax for a function definition to
notice:

Line 5: The \emph{heading} starts with \code{static void}, the name of the function,
and then parentheses.  A more general syntax for functions that just \emph{do}
something is
\begin{quote}

\code{static void} \textbf{function\_name}\code{()}
\end{quote}

Lines 6-11: The remaining lines form the function \emph{body}.  They are enclosed
in braces.  By convention the lines inside the braces are indented by a
consistent amount. Four spaces is common indentation.

The whole definition does just that: \emph{defines} the meaning of the
name \code{happyBirthdayEmily}, but it does not do anything else yet -
for example, the definition itself does not make anything be
printed yet. This is our first example of altering the order of
execution of statements from the normal sequential order. This is
important: the statements in the function \emph{definition} are \emph{not}
executed as C\# first passes over the lines.
The only part of a program that is automatically executed is \code{Main}.
Hence \code{Main} better refer to the newly defined function....

Look at the first statement inside Main, line 15:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Note that the \code{static void} of the function definition is missing,
but we still have the function name and parentheses.
C\# goes back and looks up
the definition, and only then, executes the code inside the
function definition. The term for this action is a \emph{function call}
or function \emph{invocation}.  In this simple situation the format is
\begin{quote}

\emph{function\_name}\code{()}
\end{quote}

Can you predict what the program will do?  Note the two function calls
to \code{happyBirthdayEmily}.  To see, load and run \code{birthday2.cs}.

\index{function!execution sequence}\index{execution!sequence, function}\index{sequence!function execution}
The \emph{execution} sequence for the program is different from the
\emph{textual} sequence.  Execution always starts in Main:
\begin{enumerate}
\item {} 
Line 13: Main is where execution starts, and initially proceeds
sequentially.

\item {} 
Line 15: the function is called while this location is
remembered.

\item {} 
Lines 5-11: Jump!  The code of the function is executed for the first
time, printing out the song.

\item {} 
End of line 15: Back from the function call. continue on.

\item {} 
Line 16:  Just to mix things up, print out a ``Hip, hip, hooray''.

\item {} 
Line 17: the function is called again while this location is
remembered.

\item {} 
Lines 5-11: The function is executed again, printing out the song
again.

\item {} 
End of line 17: Back from the function call, but at this point
there is nothing more in \code{Main}, and execution stops.

\end{enumerate}

Functions alter execution order in several ways: by statements not
being executed as the definition is first read, and then when the
function is called during execution, jumping to the function code,
and back at the the end of the function execution.

If it also happens to be Andre's birthday, we might define a
function \code{happyBirthdayAndre}, too. Think how to do that before
going on ....


\section{Multiple Function Definitions}
\label{multfunc::doc}\label{multfunc:multiple-function-definitions}\label{multfunc:id1}
Here is example program \code{birthday3.cs} where we add a function
\code{happyBirthdayAndre}, and call them both. Guess what happens, and
then load and try it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday3}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}   
       \PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
       \PYG{n}{happyBirthdayAndre}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Emily."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthdayAndre}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}   
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Andre."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Again, definitions are remembered and execution starts in \code{Main}.
The order in which the function definitions are given does not matter
to C\#.  It is a human choice.  For variety I show \code{Main} first.  This
means a human reading in order gets an overview of what is happening
by looking at Main, but does not know the details until reading the
definitions of the birthday functions.

Detailed order of execution:
\begin{enumerate}
\item {} 
Line 5: Start on \code{Main}

\item {} 
Line 7. This location is remembered as execution jumps to
\code{happyBirthdayEmily}

\item {} 
Lines 11-17 are executed and Emily is sung to.

\item {} 
Return to the end of Line 7: Back from \code{happyBirthdayEmily}
function call

\item {} 
Line 8: Now \code{happyBirthdayAndre} is called as this location is
remembered.

\item {} 
Lines 19-25: Sing to Andre

\item {} 
Return to the end of line 8: Back from \code{happyBirthdayAndre}
function call, done with \code{Main};
at the end of the program

\end{enumerate}

The calls to the birthday functions
\emph{happen} to be in the same order as their definitions, but that is
arbitrary. If the two lines of the body of \code{Main} were swapped,
the order of
operations would change.

Functions that you write can also call other functions you write.
In this case Main calls each of the birthday functions.


\subsection{Poem Function Exercise}
\label{multfunc:poem-function-exercise}
Write a program, \code{poem.cs}, that defines a function that
prints a \emph{short} poem or song verse. Give a meaningful name to the
function. Have the program call the function three times,
so the poem or verse is repeated three times.

\index{function!parameters}\index{parameters!function}

\section{Function Parameters}
\label{funcparam:index-0}\label{funcparam::doc}\label{funcparam:function-parameters}\label{funcparam:id1}
As a young child, you probably heard Happy Birthday sung to a
couple of people, and then you could sing to a new person, say
Maria, without needing to hear the whole special version with
Maria's name in it word for word. You had the power of
\emph{abstraction}. With examples like the versions for Emily and Andre,
you could figure out what change to make it so the song could be
sung to Maria!

Unfortunately, C\# is not that smart. It needs explicit rules.
If you needed to explain \emph{explicitly} to someone how Happy Birthday
worked in general, rather than just by example, you might say
something like this:

First you have to be \emph{given} a person's name. Then you sing the
song with the person's name inserted at the end of the third line.

C\# works something like that, but with its own syntax. The term
``person's name'' serves as a stand-in for the actual data that
will be used, ``Emily'', ``Andre'', or ``Maria''. This is just like
the association with a variable name in C\#. ``person's name''
is not a legal C\# identifier, so we will use just \code{person} as
this stand-in.  It will be a variable in the program,
so it needs a type in C\#.  The names are strings,
so the type of \code{person} is \code{string}.

The function definition indicates that the variable name \code{person}
will be used inside the function by inserting it between the
parentheses of the definition, preceeded by its type.
Then in the body of the definition
of the function, person is used in place of the real data for any
specific person's name. Read and then run example program
\code{birthday4.cs}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday4}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthday}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{person}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear "} \PYG{p}{+} \PYG{n}{person} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{happyBirthday}\PYG{p}{(}\PYG{l+s}{"Emily"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{happyBirthday}\PYG{p}{(}\PYG{l+s}{"Andre"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

In the definition heading for \code{happyBirthday}, \code{person} is
referred to as a \emph{parameter}, or a \emph{formal parameter}. This
variable name is a \emph{placeholder} for the real name of the person
being sung to.

Main now has two calls to the same function,
but between the parentheses, where there was the palceholder \code{person}
in the definition, now we have the actual people being sung to.
The value between the parentheses here in the function call
is referred to as an \emph{argument} or \emph{actual parameter} of the
function call. The argument supplies the actual data to be used in
the function execution. When the call is made, C\# does this by
associating the formal parameter name \code{person} with the actual
parameter data, as in an assignment statement. In the first call,
this actual data is \code{'Emily'}. We say the actual parameter value
is \emph{passed} to the function.

The execution in greater detail:
\begin{enumerate}
\item {} 
Lines 13: Execution starts in Main.

\item {} 
Line 15: Call to \code{happyBirthday}, with actual parameter
\code{'Emily'}.

\item {} 
Line 5: \code{'Emily'} is passed to the function, so
\code{person = 'Emily'}.

\item {} 
Lines 7-10: The song is printed, with \code{'Emily'} used as the
value of \code{person} in line 9: printing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Happy} \PYG{n}{Birthday}\PYG{p}{,} \PYG{n}{dear} \PYG{n}{Emily}\PYG{p}{.}
\end{Verbatim}

\item {} 
End of line 15 after returning from the function call

\item {} 
Line 16: Call to \code{happyBirthday}, this time with actual
parameter \code{'Andre'}

\item {} 
Line 5: \code{'Andre'} is passed to the function, so
\code{person = 'Andre'}.

\item {} 
Lines 7-10: The song is printed, with \code{'Andre'} used as the
value of \code{person} in line 9: printing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Happy} \PYG{n}{Birthday}\PYG{p}{,} \PYG{n}{dear} \PYG{n}{Andre}\PYG{p}{.}
\end{Verbatim}

\item {} 
End of line 16 after returning from the function call,
and the program is over.

\end{enumerate}

The beauty of this system is that the same function definition can
be used for a call with a different actual parameter variable, and
then have a different effect. The value of the variable person is
used in the third line of \code{happyBirthday}, to put in whatever
actual parameter value was given.

\index{abstraction}
This is the power of \emph{abstraction}. It is one application of the
most important principal in programming. Rather than have a number
of separately coded parts with only slight variations, see where it
is appropriate to combine them using a function whose parameters
refer to the parts that are different in different situations. Then
the code is written to be simultaneously appropriate for the
separate specific situations, with the substitutions of the right
parameter values.

\begin{notice}{note}{Note:}
Be sure you completely understand \code{birthday4.cs}
and the sequence of execution!  It illustrates extremely
important ideas that many people miss the first time!  It is
essential to understand the difference between
\begin{enumerate}
\item {} 
\emph{Defining} a function (lines 5-11)
with the heading including \emph{formal} parameter name and type,
where the code is merely instructions to be remembered,
not acted on immediately.

\item {} 
\emph{Calling} a function with an \emph{actual} paramerer value to be
substituted for the formal parameter,
(with \emph{no} type included!) and have the function
code actually \emph{run} when the instruction containing the call
is run.  Also note that the function can be
called multiple times with different expressions as the
actual parameter (line 15 and again in line 16).

\end{enumerate}
\end{notice}

We can combine function parameters with user input, and have the
program be able to print Happy Birthday for anyone. Check out the
main method and run \code{birthday\_who.cs}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday\PYGZus{}Who}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthday}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{person}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear "} \PYG{p}{+} \PYG{n}{person} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{userName}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Who would you like to sing Happy Birthday to?"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{userName} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{happyBirthday}\PYG{p}{(}\PYG{n}{userName}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This last version illustrates several important ideas:
\begin{enumerate}
\item {} 
There are more than one way to get information into a function:
\begin{enumerate}
\item {} 
Have a value passed in through a parameter (from line 18 to line 5).

\item {} 
Prompt the user, and obtain data from the keyboard (lines 16-17).

\end{enumerate}

\item {} 
It is a good idea to separate the \emph{internal} processing of data
from the \emph{external} input from the user by the use of distinct
functions. Here the user interaction is in \code{main}, and the data
is manipulated in \code{happyBirthday}.

\item {} 
In the first examples of actual parameters, we used literal
values. In general an actual parameter can be an expression. The
expression is evaluated before it is passed in the function call.
One of the simplest expressions is a plain variable name, which is
evaluated by replacing it with its associated value. Since it is
only the value of the actual parameter that is passed, not any
variable name, there is \emph{no need} to have a variable name used in
an actual parameter match a formal parameter name. (Here we have the
value of \code{userName} in \code{main} becoming the value of \code{person}
in \code{happyBirthday}.)

\end{enumerate}


\subsection{Birthday Function Exercise}
\label{funcparam:birthdayfunctionex}\label{funcparam:birthday-function-exercise}
Make your own further change to \code{birthday4.cs} and save it as
\code{birthdayMany.cs}: Add a function call
(but \emph{not} another function \emph{definition}), so Maria gets a verse, in
addition to Emily and Andre. Also print a blank line between
verses. (There ae two ways to handle the blank lines:
You may \emph{either} do this by adding a print line to the
function definition, \emph{or} by adding a print line between all calls to
the function.  Recall that if you give Console.WriteLine an empty
parameter list, it just goes to the next line.)

\index{function!parameter}\index{parameter!function}

\section{Multiple Function Parameters}
\label{funcparam2:index-0}\label{funcparam2:multiple-function-parameters}\label{funcparam2::doc}
A function can have more than one parameter in a parameter list
separated by commas. Each formal parameter name is preceded by its type.
For example the example program \code{addition1.cs}
uses
a function to make it easy to display many sum problems. Read and
follow the code, and then run:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Addition1}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{sumProblem}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{sum} \PYG{p}{=} \PYG{n}{x} \PYG{p}{+} \PYG{n}{y}\PYG{p}{;}
      \PYG{k+kt}{string} \PYG{n}{sentence} \PYG{p}{=} \PYG{l+s}{"The sum of "} \PYG{p}{+} \PYG{n}{x} \PYG{p}{+} \PYG{l+s}{" and "} \PYG{p}{+} \PYG{n}{y} \PYG{p}{+} \PYG{l+s}{" is "} \PYG{p}{+} \PYG{n}{sum} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sentence}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{sumProblem}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{3}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sumProblem}\PYG{p}{(}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{p}{,} \PYG{l+m}{5}\PYG{l+m}{3}\PYG{l+m}{5}\PYG{l+m}{7}\PYG{l+m}{9}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter an integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter another integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sumProblem}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\index{parameter!actual}\index{actual!parameter}\index{parameter!formal}\index{formal!parameter}
The actual parameters in the function call are evaluated left to
right, and then these values are associated with the formal
parameter names in the function definition, also left to right. For
example a function call with actual parameters,
\code{f(actual1, actual2, actual3)}, calling a function \code{f} with
definition heading:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{formal1}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{formal2}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{formal3}\PYG{p}{)}
\end{Verbatim}

acts approximately as if the first lines executed inside the called
function \code{f} were

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{formal1} \PYG{p}{=} \PYG{n}{actual1}\PYG{p}{;}
\PYG{n}{formal2} \PYG{p}{=} \PYG{n}{actual2}\PYG{p}{;}
\PYG{n}{formal3} \PYG{p}{=} \PYG{n}{actual3}\PYG{p}{;}
\end{Verbatim}

Functions provide extremely important functionality to programs,
allowing tasks to be defined once and performed repeatedly with
different data. It is essential to see the difference between the
\textbf{formal} parameters used to describe what is done inside the function
definition (like x and y in the definition of sumProblem) and the
\textbf{actual} parameters (like 2 and 3 or 12345 and 53579)
which \emph{substitute} for the formal parameters when the function is
actually executed. \code{Main} uses three different sets
of actual parameters in the three calls to sumProblem.


\subsection{Quotient Function Exercise}
\label{funcparam2:quotient-function-exercise}\label{funcparam2:quotientfunctionex}
Modify \code{quotient.cs{}`from
:ref:{}`QuotientProblem} and save it
as \code{quotientProb.cs}.
You should create a function \code{quotientProblem} with int
parameters.  Like in the earlier versions, it should print a full
sentence with inputs, quotient, and remainder.
\code{Main}
should test the \code{quotientProblem} function
on several sets of literal values, and also test the function with
input from the user.

\index{function!return math}\index{return!math, function}\index{math!function return}\index{function!sequence}\index{sequence!function}

\section{Returned Function Values}
\label{funcreturn:returned-function-values}\label{funcreturn:index-0}\label{funcreturn::doc}\label{funcreturn:id1}
You probably have used mathematical functions in algebra class, but
they all had calculated values associated with them. For instance
if you defined
\begin{quote}

f(x)=x$^{\text{2}}$
\end{quote}

then it follows that f(3) is 3$^{\text{2}}$, and f(3)+f(4) is
3$^{\text{2}}$ + 4$^{\text{2}}$

Function calls in expressions get
replaced during evaluation by the value of the function.

The corresponding definition and examples in C\# would be the
following, taken from example program \code{return1.cs}. \emph{Read}
\emph{and run}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Return1}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
       \PYG{k}{return} \PYG{n}{x}\PYG{p}{*}\PYG{n}{x}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)} \PYG{p}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The new C\# syntax is the \emph{return statement}, with the word
\code{return} followed by an expression. Functions that return values
can be used in expressions, just like in math class. When an
expression with a function call is evaluated, the function call is
effectively replaced temporarily by its returned value. Inside the
C\# function, the value to be returned is given by the
expression in the \code{return} statement.

Since the function returns data, and all data in C\# is typed,
there must be a type given for the value returned.  Note that the
function heading does not start with \code{static void}.
In place of \code{void} is \code{int}.  The \code{void} in earlier function headings
meant nothing was returned.  The \code{int} here means that a value \emph{is}
returned and its type is \code{int}.

After the function \code{f}
finishes executing from inside

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

it is as if the statement temporarily became

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and similarly when executing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)} \PYG{p}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

the interpreter first evaluates f(3) and effectively replaces the
call by the returned result, 9, as if the statement temporarily
became

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9} \PYG{p}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and then the interpreter evaluates f(4) and effectively replaces
the call by the returned result, 16, as if the statement
temporarily became

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9} \PYG{p}{+} \PYG{l+m}{1}\PYG{l+m}{6}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

resulting finally in 25 being calculated and printed.

\textbf{C\#} functions can return any type of data, not just numbers, and
there can be any number of statements executed before the return
statement. Read, follow, and run the example program
\code{return2.cs}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Return2}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{lastFirst}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{firstName}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{lastName}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{separator} \PYG{p}{=} \PYG{l+s}{", "}\PYG{p}{;}
      \PYG{k+kt}{string} \PYG{n}{result} \PYG{p}{=} \PYG{n}{lastName} \PYG{p}{+} \PYG{n}{separator} \PYG{p}{+} \PYG{n}{firstName}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{lastFirst}\PYG{p}{(}\PYG{l+s}{"Benjamin"}\PYG{p}{,} \PYG{l+s}{"Franklin"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{lastFirst}\PYG{p}{(}\PYG{l+s}{"Andrew"}\PYG{p}{,} \PYG{l+s}{"Harrington"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Many have a hard time following the flow of execution with functions.
Even more is involved when there are return vaues.
Make sure you completely follow the details of the execution:
\begin{enumerate}
\item {} 
Lines 12: Start at Main

\item {} 
Line 14: call the function, remembering where to return

\item {} 
Line 5: pass the parameters: \code{firstName = "Benjamin"};
\code{lastName = "Franklin"}

\item {} 
Line 7: Assign the variable \code{separator} the value \code{", "}

\item {} 
Line 8: Assign the variable \code{result} the value of
\code{lastName + separator + firstName} which is
\code{"Franklin" + ", " + "Benjamin"}, which evaluates to
\code{"Franklin, Benjamin"}

\item {} 
Line 9: Return \code{"Franklin, Benjamin"}

\item {} 
Line 14: Use the value returned from the function call so the line
effectively becomes  \code{Console.WriteLine("Franklin, Benjamin");},
so print it.

\item {} 
Line 15: call the function with the new actual parameters,
remembering where to return

\item {} 
Line 5: pass the parameters: \code{firstName = "Andrew"};
\code{lastName = "Harrington"}

\item {} 
Lines 7-9: ... calculate and return \code{"Harrington, Andrew"}

\item {} 
Line 15: Use the value returned by the function and print
\code{"Harrington, Andrew"}

\end{enumerate}

Compare \code{return2.cs} and \code{addition1.cs}, from the previous
section. Both use functions. Both print, but where the printing \emph{is
done} differs. The function \code{sumProblem} prints directly inside
the function and returns nothing explicitly. On the other hand
\code{lastFirst} does not print anything but returns a string. The
caller gets to decide what to do with the string, and above it is
printed in \code{Main}.

In general functions should do a single thing.
You can easily combine a sequence of functions, and you have more
flexibility in the combinations
if each does just one unified thing.  The function
sumProblem in \code{addition1.cs} does two thing:  It creates a sentence,
and prints it.  If that is all you have, you are out of luck if you want
to do something different with the sentence string.  A better way is
to have a functon that just creates the sentence, and returns it for
whatever further use you want.  After returning that value,
printing is one possibility, done in
\code{addition2.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Addition2}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{sumProblemString}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{sum} \PYG{p}{=} \PYG{n}{x} \PYG{p}{+} \PYG{n}{y}\PYG{p}{;}
      \PYG{k+kt}{string} \PYG{n}{sentence} \PYG{p}{=} \PYG{l+s}{"The sum of "} \PYG{p}{+} \PYG{n}{x} \PYG{p}{+} \PYG{l+s}{" and "} \PYG{p}{+} \PYG{n}{y} \PYG{p}{+} \PYG{l+s}{" is "} \PYG{p}{+} \PYG{n}{sum} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{sentence}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sumProblemString}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sumProblemString}\PYG{p}{(}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{p}{,} \PYG{l+m}{5}\PYG{l+m}{3}\PYG{l+m}{5}\PYG{l+m}{7}\PYG{l+m}{9}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter an integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter another integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sumProblemString}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Todo}

Put in utility functions for prompted input
\end{notice}


\subsection{Quotient String Return Exercise}
\label{funcreturn:quotient-string-return-exercise}\label{funcreturn:quotientstringex}
Create \code{quotientReturn.cs} by modifying \code{quotientProb.cs} in
{\hyperref[funcparam2:quotientfunctionex]{\emph{Quotient Function Exercise}}} so that the program accomplishes the same
thing, but everywhere change the quotientProblem function into one
called \code{quotientString} that merely \emph{returns} the string rather
than printing the string directly. Have \code{Main} print
the result of each call to the \code{quotientString} function.

\index{function!consumer}\index{consumer!function}\index{function!writer}\index{writer!function}

\section{Two Roles: Writer and Consumer of Functions}
\label{writerconsumer:index-0}\label{writerconsumer:two-roles-writer-and-consumer-of-functions}\label{writerconsumer:two-roles}\label{writerconsumer::doc}
The remainder of this section covers finer
points about functions that you might skip on a first reading.

We are only doing tiny examples so far to get the basic idea of
functions. In much larger programs, functions are useful to manage
complexity, splitting things up into logically related, modest
sized pieces. Programmers are both writers of functions and
consumers of the other functions called inside their functions. It
is useful to keep those two roles separate:

The user of an already written function needs to know:
\begin{enumerate}
\item {} 
the name of the function

\item {} 
the order and meaning of parameters

\item {} 
what is returned or produced by the function

\end{enumerate}

\emph{How} this is accomplished is not relevant at this point. For
instance, you use the work of the C\# development team, calling
functions that are built into the language. You need know the three
facts about the functions you call. You do not need to know exactly
\emph{how} the function accomplishes its purpose.

On the other hand when you \emph{write} a function you need to figure
out exactly how to accomplish your goal, name relevant variables,
and write your code, which brings us to the next section.

\index{local!scope}\index{scope!local}

\section{Local Scope}
\label{localscope:local-scope}\label{localscope:index-0}\label{localscope::doc}\label{localscope:id1}
For the logic of writing functions, it is important that the writer
of a function knows the names of variables inside the function. On
the other hand, if you are only using a function, maybe written by
someone unknown to you, you should not care what names are given to
values used internally in the implementation of the function you
are calling. C\# enforces this idea with \emph{local scope} rules:
Variable names initialized and used inside one function are
\emph{invisible} to other functions. Such variables are called \emph{local}
variables. For example, an elaboration of the earlier program
\code{return2.cs} might have its \code{lastFirst} function with its local
variable \code{separator}, but it might also have another function
that defines a \code{separator} variable, maybe with a different value
like \code{"\textbackslash{}n"}. They would not conflict. They would be
independent. This avoids lots of errors!

For example, the following code in the example program
\code{badScope.cs} causes an execution error. Read it and try to run it, and
see:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{BadScope}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{;}
      \PYG{n}{f}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//ERROR f doesn't know about the x defined in Main}
   \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The error that Mono gives is pretty clear:
\begin{quote}

The name `x' does not exist in the current context.
\end{quote}

The context for \code{x} is the function \code{f}, not \code{Main}.
We will fix this error below.

If you do want local data from one function to go to another,
define the called function so it includes parameters! Read and
compare and try the program \code{goodscope.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{BadScope}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{;}
      \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

With parameter passing, the parameter name \code{x} in the function
\code{f} does not need to match the name of the actual parameter in
the calling function \code{Main}. The definition of \code{f} could just as well have been:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{whatever}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{whatever}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\index{global!constant}\index{constant!global}

\section{Static Variables}
\label{staticvariables:index-0}\label{staticvariables:static-variables}\label{staticvariables::doc}\label{staticvariables:id1}
You may define \emph{static variables} (variables defined inside the class,
but outside of any function definition).
These variables are visible inside all of your functions.
Instead of local scope, static variables have \emph{class scope}.
It is good programming practice generally to avoid defining static variables and
instead to put your variables inside functions and explicitly pass
them as parameters where needed. One common exception
will arise when we get to defining objects.  For now a
good reason for static variables is constants:
A \emph{constant} is a name that you give a fixed data value to.
You can then use the name of the fixed data value in
expressions anywhere in the class.
A simple example program is \code{constant.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Constant}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n}{PI} \PYG{p}{=} \PYG{l+m}{3.14159265358979}\PYG{p}{;} \PYG{c+c1}{// constant, value not reset}

   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{circleArea}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{radius}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{PI}\PYG{p}{*}\PYG{n}{radius}\PYG{p}{*}\PYG{n}{radius}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{circumference}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{radius}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{l+m}{2}\PYG{p}{*}\PYG{n}{PI}\PYG{p}{*}\PYG{n}{radius}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"circle area with radius 5: "} \PYG{p}{+} \PYG{n}{circleArea}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"circumference with radius 5:"} \PYG{p}{+} \PYG{n}{circumference}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

See that \code{PI} is used in two functions without being declared locally.

By convention, names for constants are all capital letters.
\phantomsection\label{notusereturn:string-char}
\index{function!scope not use return value}\index{scope!not use return value, function}\index{not use return value!function scope}

\section{Not using Return Values}
\label{notusereturn:index-0}\label{notusereturn::doc}\label{notusereturn:not-using-return-values}
\begin{notice}{note}{Todo}

Andy new
\end{notice}

\index{assignment!functions}

\section{Assignment: Functions}
\label{assignment-functions:index-0}\label{assignment-functions:assignment-functions}\label{assignment-functions::doc}
\begin{notice}{note}{Todo}

George:
? tie into later work; good CS example?
\end{notice}


\chapter{Basic String Operations}
\label{basicstringops:basic-string-operations}\label{basicstringops::doc}\phantomsection\label{stringindexing:string-indexing}
\index{string!index}\index{index!string}

\section{String Indexing}
\label{stringindexing:index-0}\label{stringindexing::doc}\label{stringindexing:id1}
Strings are composed of characters, but be careful of the different
kinds of quotes, single for individual characters, double for strings
of 0 or more characters:
`u' (single quotes) is a char type literal, while ``u'' is a string
literal, referencing a string object. While ``you'' is a legal string
literal, `you' generates a compiler error (too many characters - only
one allowed).

Many of the operations on strings depend upon counting positions of characters
in the string. In C\#, positions are counted \emph{starting at 0}, not 1.
The indices of the characters in the string ``coding'' are labeled:

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|}
\hline

Index
 & 
0
 & 
1
 & 
2
 & 
3
 & 
4
 & 
5
\\\hline

Character
 & 
c
 & 
o
 & 
d
 & 
i
 & 
n
 & 
g
\\\hline
\end{tabulary}


The position of a character in a string is usually referred to as the
character's \emph{index}. Note that because the indices start at 0, not 1,
the index of the last character is one less that the length of the
string. This is a common source of errors. Watch out.

You can easily create an expression that refers
to an individual character inside a string.  Use
square braces around the index of the character:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{s} \PYG{p}{=} \PYG{l+s}{"coding"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{'d'}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{'c'}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{[}\PYG{l+m}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{'g'}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{greeting} \PYG{p}{=} \PYG{l+s}{"Bonjour"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{greeting}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{'o'}
\end{Verbatim}

Note from the single quotes that the result is a \code{char} in each case.

\index{double string!method}

\section{Some Instance Methods and the Length Property}
\label{stringmethods:index-0}\label{stringmethods::doc}\label{stringmethods:some-instance-methods-and-the-length-property}
Thus far we have not emphasized the use of objects, or even noted
what is an object.  Strings are a special type in C\#. We have
used string literals as parameters to functions and we have used the
special concatenation operator \code{+}.
In fact strings are objects.  Like other objects,
strings have a general notation for functions that are specially tied to the
particular type of object.  These functions are called \emph{instance methods}.
They always act on an object of the particular class, but a reference to the
object is not placed inside the parameter list, but \emph{before} the method name and
a dot as in:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{s} \PYG{p}{=} \PYG{l+s}{"hello"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"HELLO"}
\end{Verbatim}

\code{ToUpper} (converting to upper case) is particular action that makes sense
with strings.  It take s (the string object reference before the dot in this example)
and returns a new string (in upper case).  Since this action
depends only on the string itself, no further parameters are necessary,
and the parentheses after the method name are empty.  The general method syntax is
\begin{quote}

\emph{object-reference}\code{.(}\emph{further-parameters} \code{)}
\end{quote}

More string methods are listed below, some with further parameters.

Data can also be associated with object \emph{properties}.
A property of a string is its length (an int).  References to property values
use dot notation but do not have a parameter list at the end:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{s} \PYG{p}{=} \PYG{l+s}{"Hello"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{;}
\PYG{l+m}{5}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{""}\PYG{p}{.}\PYG{n}{length}\PYG{p}{;}
\PYG{l+m}{0}
\end{Verbatim}

Be careful: Though 5 is the length of \code{s} in the example above,
the last character in \code{s} is \code{s{[}4{]}}.  Using \code{s{[}5{]}} would generate
an \code{IndexOutOfRangeException}.

String objects have associated string methods which can be used to
manipulate string values.
There are an enormous number of string methods, but here are just a few
of the most common ones to get you started. The
string object to which the method is being applied is referred to as
\textbf{this} string in the descriptions.  After the methods,
the length property is also listed.
In the heading \emph{this} object is not shown explicitly, so be careful
when applying these methods and the length property: In actual use
they must be
preceeded by a reference to a string, followed by a dot, as shown in
all the  examples.  The reference to \emph{this} string can be
a variable name, a literal, or any expression evaluating to a string.
\paragraph{Some String Instance Methods and the Length Property}
\begin{description}
\item[{\code{int IndexOf(string string2)}}] \leavevmode
Returns the index of the begining of the first occurrence of the string \code{string2}
in \textbf{this} string object. Returns -1 if \code{string2} not found. Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{greeting} \PYG{p}{=} \PYG{l+s}{"Bonjour"}\PYG{p}{,} \PYG{n}{part} \PYG{p}{=} \PYG{l+s}{"jo"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{greeting}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{n}{part}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{greeting}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{"jot"}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{-}\PYG{l+m}{1}
\end{Verbatim}

\item[{\code{string substring(int start)}}] \leavevmode
Returns the substring of \textbf{this} string object starting from index \code{start}
through to the end of the string object.  Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{name} \PYG{p}{=} \PYG{l+s}{"Sheryl Crow"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{name}\PYG{p}{.}\PYG{n}{substring}\PYG{p}{(}\PYG{l+m}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"Crow"}
\end{Verbatim}

\item[{\code{string substring(int start, int len)}}] \leavevmode
Returns the substring of \textbf{this} string object starting from index \code{start},
including a total of \code{len} characters.  Example:

\begin{Verbatim}[commandchars=\\\{\}]
csharp\textgreater{} string name = "Sheryl Crow";{}`{}`
csharp\textgreater{} name.substring(3,5);
"ryl C"
\end{Verbatim}

\item[{\code{string ToUpper()}}] \leavevmode
Return a string like \textbf{this} string, except all in upper case.  Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"Hi Jane!"}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"HI JANE!"}
\end{Verbatim}

\item[{\code{string ToLower()}}] \leavevmode
Return a string like \textbf{this} string, except all in lower case.  Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"Hi Jane!"}\PYG{p}{.}\PYG{n}{ToLower}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"hi jane!"}
\end{Verbatim}

\item[{\code{int length}}] \leavevmode
Property referring to the length of \textbf{this} string object. Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{greeting} \PYG{p}{=} \PYG{l+s}{"Bonjour"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{greeting}\PYG{p}{.}\PYG{n}{length}\PYG{p}{;}  \PYG{c+c1}{//no parentheses}
\PYG{l+m}{7}
\end{Verbatim}

\end{description}


\subsection{Testing Strings For Equality}
\label{stringmethods:testing-strings-for-equality}
Strings can be tested for equality like numbers,
with \code{==}: \emph{two} equal signs, not the \emph{one} equal sign used for assignement.
The case of letters matters:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{s} \PYG{p}{=} \PYG{l+s}{"Hello"}\PYG{p}{;} \PYG{c+c1}{// initial value assigned}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{t} \PYG{p}{=} \PYG{l+s}{"HELLO"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s} \PYG{p}{=}\PYG{p}{=} \PYG{n}{t}\PYG{p}{;}  \PYG{c+c1}{// equality test}
\PYG{k}{false}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)} \PYG{p}{=}\PYG{p}{=} \PYG{n}{t}\PYG{p}{;}
\PYG{k}{true}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{u} \PYG{p}{=} \PYG{l+s}{"High"}\PYG{p}{.}\PYG{n}{substring}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// assign}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{u} \PYG{p}{=}\PYG{p}{=} \PYG{l+s}{"Hi"}\PYG{p}{;} \PYG{c+c1}{// equality test}
\PYG{k}{true}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{u} \PYG{p}{=}\PYG{p}{=} \PYG{l+s}{"High"}\PYG{p}{;}
\PYG{k}{false}
\end{Verbatim}

Hence string expressions can be used in \code{if} statements.
\phantomsection\label{problem-solving-replace:solve-string-replace}
\index{string!problem solving}\index{problem solving!string}

\section{A Creative Problem Solution}
\label{problem-solving-replace:index-0}\label{problem-solving-replace:a-creative-problem-solution}\label{problem-solving-replace::doc}
Thus far the exercises and examples suggested have been of
a very simple form, where the idea of the steps should
have been pretty clear, and the main issue was just
translating syntax into C\#, one instruction at a time.

We still have a lot of syntax to concentrate on,
but still, early on, we wanted to get in some real thought
of problem solving.  To get very interesting you
need a number of options that might be combined in
a variety of ways.  The short list of
string methods just introduced
is likely give us enough to think about....

Here is a basic string manipulation problem:
given a string, like,
\code{"It was the best of times."},
find and replace a specified part of it by another string.
For instance replace \code{"best"} by \code{"worst"}.
In this example we would get the result:
\code{"It was the worst of times."}.

It is very important to give concrete examples to
illustrate the idea desired.  Our human brains may be
very quick to see a solution like this in a very
concrete case, but what about making it general?

First this seems like a basic logical operation worthy
of a function or method, so we need a heading.
(Confession:  there are methods in the class
string for replacement, but this is a good leatrning exercise,
so we are starting over on our own.)  Since
we cannot change the string class, we will write a
static function to generate the new string.

For simplicity at the moment we will only change
the first occurence, and for now we will assume the
replacement makes sense.  The following heading
(with documentation) should work:

\begin{Verbatim}[commandchars=\\\{\}]
    
    \PYG{c+cm}{/** Return s with the first occurence of target}
\PYG{c+cm}{     *  replaced by replacement.}
\PYG{c+cm}{     */}
    \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{replaceFirst}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{target}\PYG{p}{,}
                               \PYG{k+kt}{string} \PYG{n}{replacement}\PYG{p}{)}
\end{Verbatim}

As soon as we have the calling interface, it is good to be thinking
of the tests it should pass.  Here is a Main program written
to test the function in different ways and display the results:

\begin{Verbatim}[commandchars=\\\{\}]
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{string} \PYG{n}{str1} \PYG{p}{=} \PYG{l+s}{"It was the best of times."}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{str2} \PYG{p}{=} \PYG{l+s}{"Of times it was the best."}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"str1="} \PYG{p}{+} \PYG{n}{str1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"str2="} \PYG{p}{+} \PYG{n}{str2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// to embed a quote inside a string constant, precede it by backslash(\PYGZbs{}).}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Let us do some \PYGZbs{}"cutting and pasting\PYGZbs{}" of strings!"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{str3} \PYG{p}{=} \PYG{n}{replaceFirst}\PYG{p}{(}\PYG{n}{str1}\PYG{p}{,} \PYG{l+s}{"best"}\PYG{p}{,} \PYG{l+s}{"worse"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"str3 = str1 - best to worst: "} \PYG{p}{+} \PYG{n}{str3}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{str4} \PYG{p}{=} \PYG{n}{replaceFirst}\PYG{p}{(}\PYG{n}{str2}\PYG{p}{,} \PYG{l+s}{"best"}\PYG{p}{,} \PYG{l+s}{"worse"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"str2 - best to worst: "} \PYG{p}{+} \PYG{n}{str4}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{str5} \PYG{p}{=} \PYG{n}{replaceFirst}\PYG{p}{(}\PYG{n}{str3}\PYG{p}{,} \PYG{l+s}{"worse"}\PYG{p}{,} \PYG{l+s}{"best"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"str3 - worst to best: "} \PYG{p}{+} \PYG{n}{str5}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Writing tests \emph{first} is a good idea to focus you on what really
needs to be accomplished, and then running tests later is a snap!

The human brain and eys are fabulous in the way they process
many things in parallel and use tools you have accumulated over
a lifetime.  In particular this substitution idea should
seem pretty reasonable, and given any \emph{specific concrete} example,
you are likely to be able to solve it instantly, with very little
conscious effort.  Once it becomes a programming problem, with
parameters stated in general with just placeholder formal names
like \code{s} and \code{target}, and given the limited set of approaches
you have in a programming language, the complexion of this
problem changes completely.  Many students guess the general problem will
be nearly as simple as the concrete exmples they do in their heads,
and then get very discouraged when the answer does not flow out of
them.  In fact it takes practice and experience, and it is easier
to handle if you acknowledge that up front!

So let's start in with the practice, and gain some experience.
With \code{s}, \code{target}, and \code{replacement} all being general, this
problem could easily be too much to contemplate at once,
so let us replace concrete examples by generality gradually.
The idea is to get to the end.  Rather than trying to jump a chasm,
we can take small steps and go around.

A basic idea is to make small incremental
changes, test at each stage, and gradually see more of the tests
(that you have already written) be satisfied.  Also, if you make a
mistake and screw up something that worked before, you can generally
focus on the small addition to see where the mistakes were.
\footnote{
We will not go far into the history of software engineering
practice here, but these incremental problem solving methods
were first widely
introduced as a part of \emph{extreme programming}.
That gives you an idea of the newness at the time.
}

This also avoids you needing to keep too much in your head at once.

We do have code written already:  The test code.  Start by writing
something that will trivially satisfy the first concrete test.
The body of the function can be just:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{return} \PYG{l+s}{"It was the worst of times"}\PYG{p}{;}
\end{Verbatim}

This is a tiny, easy, silly looking step, but it does accomplish
two things:  It makes sure we can produce output
in the proper string form, and the test code runs, passing the
first test.

How we gradually get more complicated.  We will continue to assume
\code{target} and \code{replacement} are as in the original example,
and \code{target} is in the same place in \code{s},
but suppose we imagine each
of the other characters in \code{s} may be something different:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{"???????????best??????????"}
\end{Verbatim}

Now we have to start thinking about what we have to work with.
We have a string, and we have string methods.
Have a look at the ideas of the each method (exact syntax
not important at the moment).  Clearly we are going to have to
deal with parts of strings, and the methods to deal with parts
involve indices, so let us add to our visual model:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Index}\PYG{p}{:} \PYG{l+m}{0}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{l+m}{6}\PYG{l+m}{7}\PYG{l+m}{8}\PYG{l+m}{9}\PYG{l+m}{0}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{l+m}{6}\PYG{l+m}{7}\PYG{l+m}{8}\PYG{l+m}{9}\PYG{l+m}{0}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}
    \PYG{n}{s}\PYG{p}{:} \PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{n}{best}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}
\end{Verbatim}

Continue in class....  The example program stub is
\code{StringmanipStub.cs}.  In general, when given a
program with ``Stub'' in it, save it under a name without the ``Stub'',
and develop that version further.  In stubs where you need to
complete a function with a return value, you will often see
a dummy choice for the return statement, just so the stub compiles.
Where the return type is string \code{"Not implemented"} is a handy
temporary choice.

When you have that function version, test it.
You will need to rename
our incremental variations so the current version has the name
used in Main.

What might further advances toward full generality be,
in small steps?  We pinned \code{best} at a specific location.
We could remove that assumption.  The location will still be
important, but we do not know it ahead of time....

A further advance would be a version that is complete
in all ways, except we still assume \code{target} is in \code{s},
but beyond that, do not assume what the three parameters are.

Finally we should allow s to not contain the target.

The testing regime in Main is clear to understand and write,
but pretty primitive.  You have to look at a lot of output
every time you test.  We will come up with better testing schemes
later.
\phantomsection\label{lab-string-ops:string-char}
\index{labs!string manipulations}

\section{Lab: String Operations}
\label{lab-string-ops:index-0}\label{lab-string-ops::doc}\label{lab-string-ops:lab-string-operations}
\begin{notice}{note}{Todo}

Andy from Java version
\end{notice}


\chapter{Decisions}
\label{decisions:decisions}\label{decisions::doc}

\section{Conditions}
\label{conditions:conditions}\label{conditions::doc}
Stub


\section{If-Statements}
\label{ifstatements:if-statements}\label{ifstatements::doc}
Stub


\chapter{Loops}
\label{loops:loops}\label{loops::doc}

\section{While-Statements}
\label{whilestatements::doc}\label{whilestatements:while-statements}
Stub


\section{For-Statements}
\label{forstatements:for-statements}\label{forstatements::doc}
Stub


\chapter{Arrays}
\label{arrays:arrays}\label{arrays::doc}

\section{One Dimensional Arrays}
\label{onedim:one-dimensional-arrays}\label{onedim::doc}
Stub


\section{Foreach Statements}
\label{foreach:foreach-statements}\label{foreach::doc}
Stub


\section{Two Dimensional Arrays}
\label{twodim::doc}\label{twodim:two-dimensional-arrays}
Stub

\begin{notice}{note}{Todo}

George:
? tie into later work; good CS example?
\end{notice}

(The {\hyperref[assignment-functions:index-1]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/devel/rst/assignment-functions.rst, line 8.)

\begin{notice}{note}{Todo}

Put in utility functions for prompted input
\end{notice}

(The {\hyperref[funcreturn:index-1]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/devel/rst/funcreturn.rst, line 142.)

\begin{notice}{note}{Todo}

Andy from Java version
\end{notice}

(The {\hyperref[lab-string-ops:index-1]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/devel/rst/lab-string-ops.rst, line 9.)

\begin{notice}{note}{Todo}

Andy new
\end{notice}

(The {\hyperref[notusereturn:index-1]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/devel/rst/notusereturn.rst, line 9.)

\begin{notice}{note}{Todo}

Andy from Java version
\end{notice}

(The \emph{original entry} is located in  /Users/anh/www/170/notes/devel/rst/stringchar.rst, line 9.)

\begin{notice}{note}{Todo}

Add the bit about using the if statement. George to work on this
later.
\end{notice}

(The {\hyperref[lab-division-sentences:index-1]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/devel/rst/lab-division-sentences.rst, line 244.)


\chapter{Index and search}
\label{index:index-and-search}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}

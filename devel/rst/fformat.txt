

.. _Defining-Own-Functions:

Defining Functions of your Own
==============================

.. index::
   double: syntax template; typography

.. _Syntax-Template-Typography:

Syntax Template Typography
--------------------------

When new C# syntax is introduced, the usual approach will be to
give both specific examples and general templates. In general
templates for C# syntax the typeface indicates the the category
of each part:

===================  ===========================================
Typeface             Meaning
===================  ===========================================
``Typewriter font``  Text to be written *verbatim*
*Emphasized*         A place where you can use an arbitrary
                     expression. 
**Bold**             A place where you can use an arbitrary
                     identifier. 
Normal text          A description of what goes in that position,
                     without giving explicit syntax
===================  ===========================================

An attempt is made with the parts that are not verbatim to be
descriptive of the use expected.

We will use these conventions shortly in the discussion of function
syntax, and will continue to use the conventions throughout the
notes.

.. index::
   double: function; definition

.. _A-First-Function:

A First Function Definition
---------------------------

If you know it is the birthday of a friend, Emily, you might tell
those gathered with you to sing "Happy Birthday to Emily".

We can make C# display the song. *Read*, and run if you like,
the example program ``birthday1.cs``:

.. literalinclude:: examples/birthday1.cs

Here the song is just a part of the ``Main`` method that is in 
every program.  

Note that we are using a function already provided to us, 
``Console.WriteLine``.  We can use it over and over, wherever we like.
We can alter its behavior by including a different parameter.
Now we look further at writing and using your own functions.

If we 
want this song to be just part of a larger program, and be able to refer
to it repeatedly and easily, we might like
to package it separately.
You would probably not repeat the whole song to let others know
what to sing. You would give a request to sing via a descriptive
name like "Happy Birthday to Emily".

In C# we can also give a name like ``happyBirthdayEmily``, and
associate the name with whole song by using a new
*function definition*, also called a *method*. We will see many variations 
on method definitions.  Later we will see definitions that are
attached to a particular object.
For now the simpler cases do not involve creating a type of object, 
but there is an extra word needed to distinguish a function definition 
*not* attached to  on object, ``static``.    
We will also shortly look at functions more like 
the functions from math class, that produce or *return* a value.  In 
this simple case we will not deal with returning a value.  
This also requires a special word in the heading:  ``void``.  A ``void``
function will just be a shorthand name for something to do, a procedure
to follow, in this case
printing out the Happy Birthday song for Emily.  (Note that 
the ``Main`` method for a program is also ``static void``.  
This *does* your whole program and is not attached to an object.)

*Read* for now:

.. literalinclude:: examples/birthday2.cs
   :linenos:
       
There are several parts of the syntax for a function definition to
notice:

Line 5: The *heading* starts with ``static void``, the name of the function,
and then parentheses.  A more general syntax for functions that just *do*
something is

    ``static void`` **function_name**\ ``()``

Lines 6-11: The remaining lines form the function *body*.  They are enclosed
in braces.  By convention the lines inside the braces are indented by a
consistent amount. Four spaces is common indentation.

The whole definition does just that: *defines* the meaning of the
name ``happyBirthdayEmily``, but it does not do anything else yet -
for example, the definition itself does not make anything be
printed yet. This is our first example of altering the order of
execution of statements from the normal sequential order. This is
important: the statements in the function *definition* are *not*
executed as C# first passes over the lines.  
The only part of a program that is automatically executed is ``Main``.
Hence ``Main`` better refer to the newly defined function....

Look at the first statement inside Main, line 15::

    happyBirthdayEmily();

Note that the ``static void`` of the function definition is missing,
but we still have the function name and parentheses. 
C# goes back and looks up
the definition, and only then, executes the code inside the
function definition. The term for this action is a *function call*
or function *invocation*.  In this simple situation the format is

    *function_name*\ ``()``

Can you predict what the program will do?  Note the two function calls
to ``happyBirthdayEmily``.  To see, load and run ``birthday2.cs``. 

.. index::
   triple: function; execution; sequence

The *execution* sequence for the program is different from the 
*textual* sequence.  Execution always starts in Main:

#. Line 13: Main is where execution starts, and initially proceeds
   sequentially.

#. Line 15: the function is called while this location is
   remembered.

#. Lines 5-11: Jump!  The code of the function is executed for the first
   time, printing out the song.

#. End of line 15: Back from the function call. continue on.

#. Line 16:  Just to mix things up, print out a "Hip, hip, hooray".

#. Line 17: the function is called again while this location is
   remembered.

#. Lines 5-11: The function is executed again, printing out the song
   again.

#. End of line 17: Back from the function call, but at this point
   there is nothing more in ``Main``, and execution stops.

Functions alter execution order in several ways: by statements not
being executed as the definition is first read, and then when the
function is called during execution, jumping to the function code,
and back at the the end of the function execution.

If it also happens to be Andre's birthday, we might define a
function ``happyBirthdayAndre``, too. Think how to do that before
going on ....

.. _Multiple-Function-Definitions:

Multiple Function Definitions
-----------------------------

Here is example program ``birthday3.cs`` where we add a function
``happyBirthdayAndre``, and call them both. Guess what happens, and
then load and try it:

.. literalinclude:: examples/birthday3.cs

Again, definitions are remembered and execution starts in ``Main``.  
The order in which the function definitions are given does not matter
to C#.  It is a human choice.  For variety I show ``Main`` first.  This 
means a human reading in order gets an overview of what is happening 
by looking at Main, but does not know the details until reading the 
definitions of the birthday functions.

Detailed order of execution:

#. Line 5: Start on ``Main``

#. Line 7. This location is remembered as execution jumps to
   ``happyBirthdayEmily``

#. Lines 11-17 are executed and Emily is sung to.

#. Return to the end of Line 7: Back from ``happyBirthdayEmily``
   function call

#. Line 8: Now ``happyBirthdayAndre`` is called as this location is
   remembered.

#. Lines 19-25: Sing to Andre

#. Return to the end of line 8: Back from ``happyBirthdayAndre``
   function call, done with ``Main``; 
   at the end of the program


The calls to the birthday functions
*happen* to be in the same order as their definitions, but that is
arbitrary. If the two lines of the body of ``Main`` were swapped, 
the order of
operations would change. 

Functions that you write can also call other functions you write.
In this case Main calls each of the birthday functions.

Poem Function Exercise
~~~~~~~~~~~~~~~~~~~~~~

Write a program, :file:`poem.cs`, that defines a function that
prints a *short* poem or song verse. Give a meaningful name to the
function. Have the program call the function three times,
so the poem or verse is repeated three times.

.. index::
   double: function; parameters

.. _Function-Parameters:

Function Parameters
-------------------

As a young child, you probably heard Happy Birthday sung to a
couple of people, and then you could sing to a new person, say
Maria, without needing to hear the whole special version with
Maria's name in it word for word. You had the power of
*abstraction*. With examples like the versions for Emily and Andre,
you could figure out what change to make it so the song could be
sung to Maria!

Unfortunately, C# is not that smart. It needs explicit rules.
If you needed to explain *explicitly* to someone how Happy Birthday
worked in general, rather than just by example, you might say
something like this:

First you have to be *given* a person's name. Then you sing the
song with the person's name inserted at the end of the third line.

C# works something like that, but with its own syntax. The term
"person's name" serves as a stand-in for the actual data that
will be used, "Emily", "Andre", or "Maria". This is just like
the association with a variable name in C#. "person's name"
is not a legal C# identifier, so we will use just ``person`` as
this stand-in.  It will be a variable in the program, 
so it needs a type in C#.  The names are strings, 
so the type of ``person`` is ``string``.

The function definition indicates that the variable name ``person``
will be used inside the function by inserting it between the
parentheses of the definition, preceeded by its type. 
Then in the body of the definition
of the function, person is used in place of the real data for any
specific person's name. Read and then run example program
``birthday4.cs``:

.. literalinclude:: examples/birthday4.cs
   :linenos:

In the definition heading for ``happyBirthday``, ``person`` is
referred to as a *parameter*, or a *formal parameter*. This
variable name is a *placeholder* for the real name of the person
being sung to.

Main now has two calls to the same function, 
but between the parentheses, where there was the palceholder ``person`` 
in the definition, now we have the actual people being sung to.
The value between the parentheses here in the function call
is referred to as an *argument* or *actual parameter* of the
function call. The argument supplies the actual data to be used in
the function execution. When the call is made, C# does this by
associating the formal parameter name ``person`` with the actual
parameter data, as in an assignment statement. In the first call,
this actual data is ``'Emily'``. We say the actual parameter value
is *passed* to the function.

The execution in greater detail:

#. Lines 13: Execution starts in Main.  

#. Line 15: Call to ``happyBirthday``, with actual parameter
   ``'Emily'``.

#. Line 5: ``'Emily'`` is passed to the function, so
   ``person = 'Emily'``.

#. Lines 7-10: The song is printed, with ``'Emily'`` used as the
   value of ``person`` in line 9: printing ::
       
       Happy Birthday, dear Emily.

#. End of line 15 after returning from the function call

#. Line 16: Call to ``happyBirthday``, this time with actual
   parameter ``'Andre'``

#. Line 5: ``'Andre'`` is passed to the function, so
   ``person = 'Andre'``.

#. Lines 7-10: The song is printed, with ``'Andre'`` used as the
   value of ``person`` in line 9: printing ::
       
       Happy Birthday, dear Andre.

#. End of line 16 after returning from the function call, 
   and the program is over.

The beauty of this system is that the same function definition can
be used for a call with a different actual parameter variable, and
then have a different effect. The value of the variable person is
used in the third line of ``happyBirthday``, to put in whatever
actual parameter value was given.

.. index:: abstraction

This is the power of *abstraction*. It is one application of the
most important principal in programming. Rather than have a number
of separately coded parts with only slight variations, see where it
is appropriate to combine them using a function whose parameters
refer to the parts that are different in different situations. Then
the code is written to be simultaneously appropriate for the
separate specific situations, with the substitutions of the right
parameter values.

.. note::

    Be sure you completely understand ``birthday4.cs``
    and the sequence of execution!  It illustrates extremely
    important ideas that many people miss the first time!  It is
    essential to understand the difference between

    1. *Defining* a function (lines 5-11)
       with the heading including *formal* parameter name and type,
       where the code is merely instructions to be remembered,
       not acted on immediately.

    2. *Calling* a function with an *actual* paramerer value to be
       substituted for the formal parameter, 
       (with *no* type included!) and have the function
       code actually *run* when the instruction containing the call
       is run.  Also note that the function can be
       called multiple times with different expressions as the
       actual parameter (line 15 and again in line 16).
       
       
		   
.. comment - the rest!		   
	
	See :ref:`BirthdayFunctionEx`.
	
	We can combine function parameters with user input, and have the
	program be able to print Happy Birthday for anyone. Check out the
	main method and run ``birthday_who.cs``:
	
	.. literalinclude:: examples/birthday_who.cs
	   :linenos:
	
	This last version illustrates several important ideas:
	
	#. There are more than one way to get information into a function:
	   
	   #. Have a value passed in through a parameter (from line 10 to line 3).
	
	   #. Prompt the user, and obtain data from the keyboard (line 11).
	
	#. It is a good idea to separate the *internal* processing of data
	   from the *external* input from the user by the use of distinct
	   functions. Here the user interaction is in ``main``, and the data
	   is manipulated in ``happyBirthday``.
	
	#. In the first examples of actual parameters, we used literal
	   values. In general an actual parameter can be an expression. The
	   expression is evaluated before it is passed in the function call.
	   One of the simplest expressions is a plain variable name, which is
	   evaluated by replacing it with its associated value. Since it is
	   only the value of the actual parameter that is passed, not any
	   variable name, there is *no need* to have a variable name used in
	   an actual parameter match a formal parameter name. (Here we have the
	   value of ``userName`` in ``main`` becoming the value of ``person``
	   in ``happyBirthday``.)
	
	.. index::
	   triple: traceback; error; execution
	
	Now that we have nested function calls, it is worth looking further
	at tracebacks from execution errors.  If I add a line to main in
	``birthday7.cs``::
		
		happyBirthday(2)
	
	as in example file ``birthdayBad.cs``, and then run it, you get
	something close to:
	
	  | Traceback (most recent call last):
	  |   File "/hands-on/examples/birthdayBad.cs", line 15, in <module>
	  |     main()
	  |   File "/hands-on/examples/birthdayBad.cs", line 13, in main
	  |     happyBirthday(2)
	  |   File "/hands-on/examples/birthdayBad.cs", line 6, in happyBirthday
	  |     print("Happy Birthday, dear " + person + ".")
	  | TypeError: Can't convert 'int' object to str implicitly
	
	Your file folder is probably different than /hands-on/examples.
	The last three lines are most important, giving the line number
	where the error was detected, the text of the line in question,
	and a description of what problem was found.  Often that is all
	you need to look at, but this example illustrates that
	the *genesis* of the problem may be far away from the line
	where the error was *detected*.  
	Going further up the traceback, you find the sequence of function
	calls that led to the line where the error was detected.
	You can see that in ``main`` I call ``happyBirthday``
	with the bad parameter, 2.
	
	.. _BirthdayFunctionEx:
	
	Birthday Function Exercise
	~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	Make your own further change to ``birthday7.cs`` and save it as
	``birthdayMany.cs``: Add a function call
	(but *not* another function *definition*), so Maria gets a verse, in
	addition to Emily and Andre. Also print a blank line between
	verses. (You may *either* do this by adding a print line to the
	function definition, *or* by adding a print line between all calls to
	the function.)
	
	.. index::
	   double: function; parameter
	
	Multiple Function Parameters
	----------------------------
	
	A function can have more than one parameter in a parameter list
	separated by commas. Here the example program :file:`addition5.cs` changes
	example program :file:`addition4a.cs`, using
	a function to make it easy to display many sum problems. Read and
	follow the code, and then run:
	
	.. literalinclude:: examples/addition5.cs
	   :language: C#3
	
	.. index::
	   double: parameter; actual
	   double: parameter; formal
	
	The actual parameters in the function call are evaluated left to
	right, and then these values are associated with the formal
	parameter names in the function definition, also left to right. For
	example a function call with actual parameters,
	``f(actual1, actual2, actual3)``, calling a function f with
	definition heading::
	
		def f(formal1, formal2, formal3):
	
	acts approximately as if the first lines executed inside the called
	function ``f`` were ::
	
		formal1 = actual1 
		formal2 = actual2 
		formal3 = actual3 
	
	Functions provide extremely important functionality to programs,
	allowing tasks to be defined once and performed repeatedly with
	different data. It is essential to see the difference between the
	**formal** parameters used to describe what is done inside the function
	definition (like x and y in the definition of sumProblem) and the
	**actual** parameters (like 2 and 3 or 1234567890123 and 535790269358)
	which *substitute* for the formal parameters when the function is
	actually executed. The main method above uses three different sets
	of actual parameters in the three calls to sumProblem.
	
	.. _QuotientFunctionEx:
	
	Quotient Function Exercise
	~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	The example ``addition5.cs`` is a modification of ``addition4a.cs``,
	putting the arithmetic problem into a function and then calling the function
	several times with different parameters.
	Similarly modify :file:`quotientformat.cs`from
	:ref:`QuotientFormatProblem` and save it
	as ``quotientProb.cs``.
	You should create a function ``quotientProblem`` with numerical
	parameters.  Like in all the earlier versions, it should print a full
	sentence with input, quotient, and remainder.
	The ``main`` method in the new program
	should test the quotientProblem function
	on several sets of literal values, and also test the function with
	input from the user.
	
	.. index::
	   triple: function; return; math
	   double: function; sequence
	
	.. _Returned-Function-Values:
	
	Returned Function Values
	------------------------
	
	..
		:math:`$f(x)=x^{2}$`, then it follows that
		:math:`$f(3)$` is :math:`$3^{2}=9$`, and :math:`$f(3)+f(4)$` is
		:math:`$3^{2}+4^{2}=25$`
	
	
	You probably have used mathematical functions in algebra class, but
	they all had calculated values associated with them. For instance
	if you defined 
	
	   f(x)=x\ :sup:`2`
	
	then it follows that f(3) is 3\ :sup:`2`, and f(3)+f(4) is
	3\ :sup:`2` + 4\ :sup:`2`
	
	Function calls in expressions get
	replaced during evaluation by the value of the function.
	
	The corresponding definition and examples in C# would be the
	following, taken from example program ``return1.cs``. *Read*
	*and run*:
	
	.. literalinclude:: examples/return1.cs
	
	The new C# syntax is the *return statement*, with the word
	``return`` followed by an expression. Functions that return values
	can be used in expressions, just like in math class. When an
	expression with a function call is evaluated, the function call is
	effectively replaced temporarily by its returned value. Inside the
	C# function, the value to be returned is given by the
	expression in the ``return`` statement.
	
	After the function ``f``
	finishes executing from inside ::
	
		print(f(3))
	
	it is as if the statement temporarily became ::
	
		print(9)
	
	and similarly when executing ::
	
		print(f(3) + f(4)) 
	
	the interpreter first evaluates f(3) and effectively replaces the
	call by the returned result, 9, as if the statement temporarily
	became ::
	
		print(9 + f(4))
	
	
	and then the interpreter evaluates f(4) and effectively replaces
	the call by the returned result, 16, as if the statement
	temporarily became ::
	
		print(9 + 16)
	
	resulting finally in 25 being calculated and printed.
	
	**C#** functions can return any type of data, not just numbers, and
	there can be any number of statements executed before the return
	statement. Read, follow, and run the example program
	``return2.cs``:
	
	.. literalinclude:: examples/return2.cs
	   :linenos:
	
	The code above has a new feature, variables ``separator`` and
	``result`` are given a value inside the function, but ``separator`` and
	``result`` are *not* among the formal parameters. The assignments
	work as you would expect here. More on this shortly, in
	:ref:`Local-Scope`.
	
	Details of the execution:
	
	#. Lines 3-6: Remember the definition
	
	#. Line 8: call the function, remembering where to return
	
	#. Line 3: pass the parameters: ``firstName = 'Benjamin'``;
	   ``lastName = 'Franklin'``
	
	#. Line 4: Assign the variable ``separator`` the value ``''``
	
	#. Line 5: Assign the variable ``result`` the value of 
	   ``lastName + separator + firstName`` which is  
	   ``'Franklin' + ', ' + 'Benjamin'``, which evaluates to
	   ``'Franklin, Benjamin'``
	
	#. Line 6: Return ``'Franklin, Benjamin'``
	
	#. Line 8: Use the value returned from the function call so the line
	   effectively becomes  ``print('Franklin, Benjamin')``, 
	   so print it.
	
	#. Line 9: call the function with the new actual parameters,
	   remembering where to return
	
	#. Line 3: pass the parameters: ``firstName = 'Andrew'``;
	   ``lastName = 'Harrington'``
	
	#. Lines 4-6: ... calculate and return ``'Harrington, Andrew'``
	
	#. Line 9: Use the value returned by the function and print
	   ``'Harrington, Andrew'``
	
	Compare ``return2.cs`` and ``addition5.cs``, from the previous
	section. Both use functions. Both print, but where the printing *is
	done* differs. The function ``sumProblem`` prints directly inside
	the function and returns nothing explicitly. On the other hand
	``lastFirst`` does not print anything but returns a string. The
	caller gets to decide what to do with the string, and above it is
	printed in the main program.
	
	.. index::
	   double: None; return
	
	Open ``addition5.cs`` again, and introduce a *common mistake*.
	Change the last line of the function ``main`` inserting ``print``,
	so it says ::
	
		print(sumProblem(a, b))
	
	Then try running the program. The desired printing is actually done
	inside the function sumProblem. You introduced a statement to print
	what ``sumProblem`` *returns*. Although ``sumProblem`` returns
	nothing *explicitly*, C# does make every function return
	something. If there is nothing explicitly returned, the special
	value ``None`` is returned. You should see that in the Shell
	output. This is a fairly common error.
	
	..  warning::
		If you see a 'None' is your
		output where you do not expect it, it is likely that you have
		printed the return value of a function that did not return anything
		explicitly!
	
	In general functions should do a single thing.
	You can easily combine a sequence of functions, and you have more
	flexibility in the combinations
	if each does just one unified thing.  The function
	sumProblem in :file:`addition5.cs` does two thing:  It creates a sentence,
	and prints it.  If that is all you have, you are out of luck if you want
	to do something different with the sentence string.  A better way is
	to have a functon that just creates the sentence, and returns it for
	whatever further use you want.  Printing is one possibility, done in
	:file:`addition6.cs`:
	
	.. literalinclude:: examples/addition6.cs
	   :language: C#3
	
		
	.. _QuotientStringEx:
		
	Quotient String Return Exercise
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	Create :file:`quotientReturn.cs` by modifying :file:`quotientProb.cs` in
	:ref:`QuotientFunctionEx` so that the program accomplishes the same
	thing, but everywhere change the quotientProblem function into one
	called ``quotientString`` that merely *returns* the string rather
	than printing the string directly. Have the ``main`` function print
	the result of each call to the ``quotientString`` function.
	
	.. index::
	   double: function; consumer
	   double: function; writer
	
	.. _Two-Roles:
	
	Two Roles: Writer and Consumer of Functions
	-------------------------------------------
	
	The remainder of this section covers finer
	points about functions that you might skip on a first reading.
	
	We are only doing tiny examples so far to get the basic idea of
	functions. In much larger programs, functions are useful to manage
	complexity, splitting things up into logically related, modest
	sized pieces. Programmers are both writers of functions and
	consumers of the other functions called inside their functions. It
	is useful to keep those two roles separate:
	
	The user of an already written function needs to know:
	
	#. the name of the function
	
	#. the order and meaning of parameters
	
	#. what is returned or produced by the function
	
	
	*How* this is accomplished is not relevant at this point. For
	instance, you use the work of the C# development team, calling
	functions that are built into the language. You need know the three
	facts about the functions you call. You do not need to know exactly
	*how* the function accomplishes its purpose.
	
	On the other hand when you *write* a function you need to figure
	out exactly how to accomplish your goal, name relevant variables,
	and write your code, which brings us to the next section.
	
	.. index::
	   double: local; scope
	
	.. _Local-Scope:
	
	Local Scope
	-----------
	
	For the logic of writing functions, it is important that the writer
	of a function knows the names of variables inside the function. On
	the other hand, if you are only using a function, maybe written by
	someone unknown to you, you should not care what names are given to
	values used internally in the implementation of the function you
	are calling. C# enforces this idea with *local scope* rules:
	Variable names initialized and used inside one function are
	*invisible* to other functions. Such variables are called *local*
	variables. For example, an elaboration of the earlier program
	``return2.cs`` might have its ``lastFirst`` function with its local
	variable ``separator``, but it might also have another function
	that defines a ``separator`` variable, maybe with a different value
	like ``'\n'``. They would not conflict. They would be 
	independent. This avoids lots of errors!
	
	For example, the following code in the example program
	``badScope.cs`` causes an execution error. Read it and run it, and
	see:
	
	.. literalinclude:: examples/badScope.cs
	
	We will fix this error below. The execution error message mentions
	"global name". Names defined outside any function definition, at
	the "top-level" of your program are called *global*. They are a
	special case. They are discussed more in the next section.
	
	If you do want local data from one function to go to another,
	define the called function so it includes parameters! Read and
	compare and try the program ``goodScope.cs``:
	
	.. literalinclude:: examples/goodScope.cs
	
	With parameter passing, the parameter name ``x`` in the function
	``f`` does not need to match the name of the actual parameter in
	``main``. The definition of ``f`` could just as well have been::
	
		def f(whatever): 
			print(whatever) 
	
	.. index::
	   double: global; constant
	
	.. _Global-Constants:
	
	Global Constants
	----------------
	
	If you define *global variables* (variables defined outside of any function
	definition), they are visible inside all of your functions. It is
	good programming practice to avoid defining global variables and
	instead to put your variables inside functions and explicitly pass
	them as parameters where needed. One common exception is constants:
	A *constant* is a name that you give a fixed data value to, by
	assigning a value to the name only in a single assignment
	statement. You can then use the name of the fixed data value in
	expressions later. A simple example program is ``constant.cs``:
	
	.. literalinclude:: examples/constant.cs
	
	This example uses numbers with decimal points, discussed more in
	:ref:`Floats`. By convention, names for
	constants are all capital letters.
	
	Issues with global variables do not come up if they are only used
	as constants.
	
	Function names defined at the top-level also have global scope.
	This is what allows you to use one function you defined inside
	another function you define.
	
